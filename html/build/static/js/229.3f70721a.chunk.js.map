{"version":3,"file":"static/js/229.3f70721a.chunk.js","mappings":"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","sources":["../node_modules/shallowequal/index.js","../node_modules/style-to-object/index.js","../node_modules/xtend/immutable.js","../node_modules/space-separated-tokens/index.js","../node_modules/stylis/src/Enum.js","../node_modules/stylis/src/Tokenizer.js","../node_modules/stylis/src/Parser.js","../node_modules/stylis/src/Serializer.js","../node_modules/stylis/src/Utility.js","../node_modules/trim-lines/index.js","../node_modules/unified/node_modules/is-plain-obj/index.js","../node_modules/trough/index.js","../node_modules/unified/lib/index.js","../node_modules/unist-builder/index.js","../node_modules/unist-util-find-after/index.js","../node_modules/unist-util-generated/index.js","../node_modules/unist-util-is/index.js","../node_modules/unist-util-position/index.js","../node_modules/unist-util-remove-position/index.js","../node_modules/unist-util-stringify-position/index.js","../node_modules/unist-util-visit-parents/index.js","../node_modules/unist-util-visit/index.js","../node_modules/vfile-location/index.js","../node_modules/vfile-message/index.js","../node_modules/vfile/lib/minpath.browser.js","../node_modules/vfile/lib/minproc.browser.js","../node_modules/vfile/lib/minurl.shared.js","../node_modules/vfile/lib/minurl.browser.js","../node_modules/vfile/lib/index.js","../node_modules/web-namespaces/index.js","../node_modules/zwitch/index.js"],"sourcesContent":["//\n\nmodule.exports = function shallowEqual(objA, objB, compare, compareContext) {\n  var ret = compare ? compare.call(compareContext, objA, objB) : void 0;\n\n  if (ret !== void 0) {\n    return !!ret;\n  }\n\n  if (objA === objB) {\n    return true;\n  }\n\n  if (typeof objA !== \"object\" || !objA || typeof objB !== \"object\" || !objB) {\n    return false;\n  }\n\n  var keysA = Object.keys(objA);\n  var keysB = Object.keys(objB);\n\n  if (keysA.length !== keysB.length) {\n    return false;\n  }\n\n  var bHasOwnProperty = Object.prototype.hasOwnProperty.bind(objB);\n\n  // Test for A's keys different from B.\n  for (var idx = 0; idx < keysA.length; idx++) {\n    var key = keysA[idx];\n\n    if (!bHasOwnProperty(key)) {\n      return false;\n    }\n\n    var valueA = objA[key];\n    var valueB = objB[key];\n\n    ret = compare ? compare.call(compareContext, valueA, valueB, key) : void 0;\n\n    if (ret === false || (ret === void 0 && valueA !== valueB)) {\n      return false;\n    }\n  }\n\n  return true;\n};\n","var parse = require('inline-style-parser');\n\n/**\n * Parses inline style to object.\n *\n * @example\n * // returns { 'line-height': '42' }\n * StyleToObject('line-height: 42;');\n *\n * @param  {String}      style      - The inline style.\n * @param  {Function}    [iterator] - The iterator function.\n * @return {null|Object}\n */\nfunction StyleToObject(style, iterator) {\n  var output = null;\n  if (!style || typeof style !== 'string') {\n    return output;\n  }\n\n  var declaration;\n  var declarations = parse(style);\n  var hasIterator = typeof iterator === 'function';\n  var property;\n  var value;\n\n  for (var i = 0, len = declarations.length; i < len; i++) {\n    declaration = declarations[i];\n    property = declaration.property;\n    value = declaration.value;\n\n    if (hasIterator) {\n      iterator(property, value, declaration);\n    } else if (value) {\n      output || (output = {});\n      output[property] = value;\n    }\n  }\n\n  return output;\n}\n\nmodule.exports = StyleToObject;\n","module.exports = extend\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction extend() {\n    var target = {}\n\n    for (var i = 0; i < arguments.length; i++) {\n        var source = arguments[i]\n\n        for (var key in source) {\n            if (hasOwnProperty.call(source, key)) {\n                target[key] = source[key]\n            }\n        }\n    }\n\n    return target\n}\n","/**\n * Parse space-separated tokens to an array of strings.\n *\n * @param {string} value\n *   Space-separated tokens.\n * @returns {Array<string>}\n *   List of tokens.\n */\nexport function parse(value) {\n  const input = String(value || '').trim()\n  return input ? input.split(/[ \\t\\n\\r\\f]+/g) : []\n}\n\n/**\n * Serialize an array of strings as space separated-tokens.\n *\n * @param {Array<string|number>} values\n *   List of tokens.\n * @returns {string}\n *   Space-separated tokens.\n */\nexport function stringify(values) {\n  return values.join(' ').trim()\n}\n","export var MS = '-ms-'\nexport var MOZ = '-moz-'\nexport var WEBKIT = '-webkit-'\n\nexport var COMMENT = 'comm'\nexport var RULESET = 'rule'\nexport var DECLARATION = 'decl'\n\nexport var PAGE = '@page'\nexport var MEDIA = '@media'\nexport var IMPORT = '@import'\nexport var CHARSET = '@charset'\nexport var VIEWPORT = '@viewport'\nexport var SUPPORTS = '@supports'\nexport var DOCUMENT = '@document'\nexport var NAMESPACE = '@namespace'\nexport var KEYFRAMES = '@keyframes'\nexport var FONT_FACE = '@font-face'\nexport var COUNTER_STYLE = '@counter-style'\nexport var FONT_FEATURE_VALUES = '@font-feature-values'\n","import {from, trim, charat, strlen, substr, append, assign} from './Utility.js'\n\nexport var line = 1\nexport var column = 1\nexport var length = 0\nexport var position = 0\nexport var character = 0\nexport var characters = ''\n\n/**\n * @param {string} value\n * @param {object | null} root\n * @param {object | null} parent\n * @param {string} type\n * @param {string[] | string} props\n * @param {object[] | string} children\n * @param {number} length\n */\nexport function node (value, root, parent, type, props, children, length) {\n\treturn {value: value, root: root, parent: parent, type: type, props: props, children: children, line: line, column: column, length: length, return: ''}\n}\n\n/**\n * @param {object} root\n * @param {object} props\n * @return {object}\n */\nexport function copy (root, props) {\n\treturn assign(node('', null, null, '', null, null, 0), root, {length: -root.length}, props)\n}\n\n/**\n * @return {number}\n */\nexport function char () {\n\treturn character\n}\n\n/**\n * @return {number}\n */\nexport function prev () {\n\tcharacter = position > 0 ? charat(characters, --position) : 0\n\n\tif (column--, character === 10)\n\t\tcolumn = 1, line--\n\n\treturn character\n}\n\n/**\n * @return {number}\n */\nexport function next () {\n\tcharacter = position < length ? charat(characters, position++) : 0\n\n\tif (column++, character === 10)\n\t\tcolumn = 1, line++\n\n\treturn character\n}\n\n/**\n * @return {number}\n */\nexport function peek () {\n\treturn charat(characters, position)\n}\n\n/**\n * @return {number}\n */\nexport function caret () {\n\treturn position\n}\n\n/**\n * @param {number} begin\n * @param {number} end\n * @return {string}\n */\nexport function slice (begin, end) {\n\treturn substr(characters, begin, end)\n}\n\n/**\n * @param {number} type\n * @return {number}\n */\nexport function token (type) {\n\tswitch (type) {\n\t\t// \\0 \\t \\n \\r \\s whitespace token\n\t\tcase 0: case 9: case 10: case 13: case 32:\n\t\t\treturn 5\n\t\t// ! + , / > @ ~ isolate token\n\t\tcase 33: case 43: case 44: case 47: case 62: case 64: case 126:\n\t\t// ; { } breakpoint token\n\t\tcase 59: case 123: case 125:\n\t\t\treturn 4\n\t\t// : accompanied token\n\t\tcase 58:\n\t\t\treturn 3\n\t\t// \" ' ( [ opening delimit token\n\t\tcase 34: case 39: case 40: case 91:\n\t\t\treturn 2\n\t\t// ) ] closing delimit token\n\t\tcase 41: case 93:\n\t\t\treturn 1\n\t}\n\n\treturn 0\n}\n\n/**\n * @param {string} value\n * @return {any[]}\n */\nexport function alloc (value) {\n\treturn line = column = 1, length = strlen(characters = value), position = 0, []\n}\n\n/**\n * @param {any} value\n * @return {any}\n */\nexport function dealloc (value) {\n\treturn characters = '', value\n}\n\n/**\n * @param {number} type\n * @return {string}\n */\nexport function delimit (type) {\n\treturn trim(slice(position - 1, delimiter(type === 91 ? type + 2 : type === 40 ? type + 1 : type)))\n}\n\n/**\n * @param {string} value\n * @return {string[]}\n */\nexport function tokenize (value) {\n\treturn dealloc(tokenizer(alloc(value)))\n}\n\n/**\n * @param {number} type\n * @return {string}\n */\nexport function whitespace (type) {\n\twhile (character = peek())\n\t\tif (character < 33)\n\t\t\tnext()\n\t\telse\n\t\t\tbreak\n\n\treturn token(type) > 2 || token(character) > 3 ? '' : ' '\n}\n\n/**\n * @param {string[]} children\n * @return {string[]}\n */\nexport function tokenizer (children) {\n\twhile (next())\n\t\tswitch (token(character)) {\n\t\t\tcase 0: append(identifier(position - 1), children)\n\t\t\t\tbreak\n\t\t\tcase 2: append(delimit(character), children)\n\t\t\t\tbreak\n\t\t\tdefault: append(from(character), children)\n\t\t}\n\n\treturn children\n}\n\n/**\n * @param {number} index\n * @param {number} count\n * @return {string}\n */\nexport function escaping (index, count) {\n\twhile (--count && next())\n\t\t// not 0-9 A-F a-f\n\t\tif (character < 48 || character > 102 || (character > 57 && character < 65) || (character > 70 && character < 97))\n\t\t\tbreak\n\n\treturn slice(index, caret() + (count < 6 && peek() == 32 && next() == 32))\n}\n\n/**\n * @param {number} type\n * @return {number}\n */\nexport function delimiter (type) {\n\twhile (next())\n\t\tswitch (character) {\n\t\t\t// ] ) \" '\n\t\t\tcase type:\n\t\t\t\treturn position\n\t\t\t// \" '\n\t\t\tcase 34: case 39:\n\t\t\t\tif (type !== 34 && type !== 39)\n\t\t\t\t\tdelimiter(character)\n\t\t\t\tbreak\n\t\t\t// (\n\t\t\tcase 40:\n\t\t\t\tif (type === 41)\n\t\t\t\t\tdelimiter(type)\n\t\t\t\tbreak\n\t\t\t// \\\n\t\t\tcase 92:\n\t\t\t\tnext()\n\t\t\t\tbreak\n\t\t}\n\n\treturn position\n}\n\n/**\n * @param {number} type\n * @param {number} index\n * @return {number}\n */\nexport function commenter (type, index) {\n\twhile (next())\n\t\t// //\n\t\tif (type + character === 47 + 10)\n\t\t\tbreak\n\t\t// /*\n\t\telse if (type + character === 42 + 42 && peek() === 47)\n\t\t\tbreak\n\n\treturn '/*' + slice(index, position - 1) + '*' + from(type === 47 ? type : next())\n}\n\n/**\n * @param {number} index\n * @return {string}\n */\nexport function identifier (index) {\n\twhile (!token(peek()))\n\t\tnext()\n\n\treturn slice(index, position)\n}\n","import {COMMENT, RULESET, DECLARATION} from './Enum.js'\nimport {abs, charat, trim, from, sizeof, strlen, substr, append, replace, indexof} from './Utility.js'\nimport {node, char, prev, next, peek, caret, alloc, dealloc, delimit, whitespace, escaping, identifier, commenter} from './Tokenizer.js'\n\n/**\n * @param {string} value\n * @return {object[]}\n */\nexport function compile (value) {\n\treturn dealloc(parse('', null, null, null, [''], value = alloc(value), 0, [0], value))\n}\n\n/**\n * @param {string} value\n * @param {object} root\n * @param {object?} parent\n * @param {string[]} rule\n * @param {string[]} rules\n * @param {string[]} rulesets\n * @param {number[]} pseudo\n * @param {number[]} points\n * @param {string[]} declarations\n * @return {object}\n */\nexport function parse (value, root, parent, rule, rules, rulesets, pseudo, points, declarations) {\n\tvar index = 0\n\tvar offset = 0\n\tvar length = pseudo\n\tvar atrule = 0\n\tvar property = 0\n\tvar previous = 0\n\tvar variable = 1\n\tvar scanning = 1\n\tvar ampersand = 1\n\tvar character = 0\n\tvar type = ''\n\tvar props = rules\n\tvar children = rulesets\n\tvar reference = rule\n\tvar characters = type\n\n\twhile (scanning)\n\t\tswitch (previous = character, character = next()) {\n\t\t\t// (\n\t\t\tcase 40:\n\t\t\t\tif (previous != 108 && charat(characters, length - 1) == 58) {\n\t\t\t\t\tif (indexof(characters += replace(delimit(character), '&', '&\\f'), '&\\f') != -1)\n\t\t\t\t\t\tampersand = -1\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t// \" ' [\n\t\t\tcase 34: case 39: case 91:\n\t\t\t\tcharacters += delimit(character)\n\t\t\t\tbreak\n\t\t\t// \\t \\n \\r \\s\n\t\t\tcase 9: case 10: case 13: case 32:\n\t\t\t\tcharacters += whitespace(previous)\n\t\t\t\tbreak\n\t\t\t// \\\n\t\t\tcase 92:\n\t\t\t\tcharacters += escaping(caret() - 1, 7)\n\t\t\t\tcontinue\n\t\t\t// /\n\t\t\tcase 47:\n\t\t\t\tswitch (peek()) {\n\t\t\t\t\tcase 42: case 47:\n\t\t\t\t\t\tappend(comment(commenter(next(), caret()), root, parent), declarations)\n\t\t\t\t\t\tbreak\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tcharacters += '/'\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t// {\n\t\t\tcase 123 * variable:\n\t\t\t\tpoints[index++] = strlen(characters) * ampersand\n\t\t\t// } ; \\0\n\t\t\tcase 125 * variable: case 59: case 0:\n\t\t\t\tswitch (character) {\n\t\t\t\t\t// \\0 }\n\t\t\t\t\tcase 0: case 125: scanning = 0\n\t\t\t\t\t// ;\n\t\t\t\t\tcase 59 + offset:\n\t\t\t\t\t\tif (property > 0 && (strlen(characters) - length))\n\t\t\t\t\t\t\tappend(property > 32 ? declaration(characters + ';', rule, parent, length - 1) : declaration(replace(characters, ' ', '') + ';', rule, parent, length - 2), declarations)\n\t\t\t\t\t\tbreak\n\t\t\t\t\t// @ ;\n\t\t\t\t\tcase 59: characters += ';'\n\t\t\t\t\t// { rule/at-rule\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tappend(reference = ruleset(characters, root, parent, index, offset, rules, points, type, props = [], children = [], length), rulesets)\n\n\t\t\t\t\t\tif (character === 123)\n\t\t\t\t\t\t\tif (offset === 0)\n\t\t\t\t\t\t\t\tparse(characters, root, reference, reference, props, rulesets, length, points, children)\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tswitch (atrule === 99 && charat(characters, 3) === 110 ? 100 : atrule) {\n\t\t\t\t\t\t\t\t\t// d m s\n\t\t\t\t\t\t\t\t\tcase 100: case 109: case 115:\n\t\t\t\t\t\t\t\t\t\tparse(value, reference, reference, rule && append(ruleset(value, reference, reference, 0, 0, rules, points, type, rules, props = [], length), children), rules, children, length, points, rule ? props : children)\n\t\t\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\tparse(characters, reference, reference, reference, [''], children, 0, points, children)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tindex = offset = property = 0, variable = ampersand = 1, type = characters = '', length = pseudo\n\t\t\t\tbreak\n\t\t\t// :\n\t\t\tcase 58:\n\t\t\t\tlength = 1 + strlen(characters), property = previous\n\t\t\tdefault:\n\t\t\t\tif (variable < 1)\n\t\t\t\t\tif (character == 123)\n\t\t\t\t\t\t--variable\n\t\t\t\t\telse if (character == 125 && variable++ == 0 && prev() == 125)\n\t\t\t\t\t\tcontinue\n\n\t\t\t\tswitch (characters += from(character), character * variable) {\n\t\t\t\t\t// &\n\t\t\t\t\tcase 38:\n\t\t\t\t\t\tampersand = offset > 0 ? 1 : (characters += '\\f', -1)\n\t\t\t\t\t\tbreak\n\t\t\t\t\t// ,\n\t\t\t\t\tcase 44:\n\t\t\t\t\t\tpoints[index++] = (strlen(characters) - 1) * ampersand, ampersand = 1\n\t\t\t\t\t\tbreak\n\t\t\t\t\t// @\n\t\t\t\t\tcase 64:\n\t\t\t\t\t\t// -\n\t\t\t\t\t\tif (peek() === 45)\n\t\t\t\t\t\t\tcharacters += delimit(next())\n\n\t\t\t\t\t\tatrule = peek(), offset = length = strlen(type = characters += identifier(caret())), character++\n\t\t\t\t\t\tbreak\n\t\t\t\t\t// -\n\t\t\t\t\tcase 45:\n\t\t\t\t\t\tif (previous === 45 && strlen(characters) == 2)\n\t\t\t\t\t\t\tvariable = 0\n\t\t\t\t}\n\t\t}\n\n\treturn rulesets\n}\n\n/**\n * @param {string} value\n * @param {object} root\n * @param {object?} parent\n * @param {number} index\n * @param {number} offset\n * @param {string[]} rules\n * @param {number[]} points\n * @param {string} type\n * @param {string[]} props\n * @param {string[]} children\n * @param {number} length\n * @return {object}\n */\nexport function ruleset (value, root, parent, index, offset, rules, points, type, props, children, length) {\n\tvar post = offset - 1\n\tvar rule = offset === 0 ? rules : ['']\n\tvar size = sizeof(rule)\n\n\tfor (var i = 0, j = 0, k = 0; i < index; ++i)\n\t\tfor (var x = 0, y = substr(value, post + 1, post = abs(j = points[i])), z = value; x < size; ++x)\n\t\t\tif (z = trim(j > 0 ? rule[x] + ' ' + y : replace(y, /&\\f/g, rule[x])))\n\t\t\t\tprops[k++] = z\n\n\treturn node(value, root, parent, offset === 0 ? RULESET : type, props, children, length)\n}\n\n/**\n * @param {number} value\n * @param {object} root\n * @param {object?} parent\n * @return {object}\n */\nexport function comment (value, root, parent) {\n\treturn node(value, root, parent, COMMENT, from(char()), substr(value, 2, -2), 0)\n}\n\n/**\n * @param {string} value\n * @param {object} root\n * @param {object?} parent\n * @param {number} length\n * @return {object}\n */\nexport function declaration (value, root, parent, length) {\n\treturn node(value, root, parent, DECLARATION, substr(value, 0, length), substr(value, length + 1, -1), length)\n}\n","import {IMPORT, COMMENT, RULESET, DECLARATION, KEYFRAMES} from './Enum.js'\nimport {strlen, sizeof} from './Utility.js'\n\n/**\n * @param {object[]} children\n * @param {function} callback\n * @return {string}\n */\nexport function serialize (children, callback) {\n\tvar output = ''\n\tvar length = sizeof(children)\n\n\tfor (var i = 0; i < length; i++)\n\t\toutput += callback(children[i], i, children, callback) || ''\n\n\treturn output\n}\n\n/**\n * @param {object} element\n * @param {number} index\n * @param {object[]} children\n * @param {function} callback\n * @return {string}\n */\nexport function stringify (element, index, children, callback) {\n\tswitch (element.type) {\n\t\tcase IMPORT: case DECLARATION: return element.return = element.return || element.value\n\t\tcase COMMENT: return ''\n\t\tcase KEYFRAMES: return element.return = element.value + '{' + serialize(element.children, callback) + '}'\n\t\tcase RULESET: element.value = element.props.join(',')\n\t}\n\n\treturn strlen(children = serialize(element.children, callback)) ? element.return = element.value + '{' + children + '}' : ''\n}\n","/**\n * @param {number}\n * @return {number}\n */\nexport var abs = Math.abs\n\n/**\n * @param {number}\n * @return {string}\n */\nexport var from = String.fromCharCode\n\n/**\n * @param {object}\n * @return {object}\n */\nexport var assign = Object.assign\n\n/**\n * @param {string} value\n * @param {number} length\n * @return {number}\n */\nexport function hash (value, length) {\n\treturn charat(value, 0) ^ 45 ? (((((((length << 2) ^ charat(value, 0)) << 2) ^ charat(value, 1)) << 2) ^ charat(value, 2)) << 2) ^ charat(value, 3) : 0\n}\n\n/**\n * @param {string} value\n * @return {string}\n */\nexport function trim (value) {\n\treturn value.trim()\n}\n\n/**\n * @param {string} value\n * @param {RegExp} pattern\n * @return {string?}\n */\nexport function match (value, pattern) {\n\treturn (value = pattern.exec(value)) ? value[0] : value\n}\n\n/**\n * @param {string} value\n * @param {(string|RegExp)} pattern\n * @param {string} replacement\n * @return {string}\n */\nexport function replace (value, pattern, replacement) {\n\treturn value.replace(pattern, replacement)\n}\n\n/**\n * @param {string} value\n * @param {string} search\n * @return {number}\n */\nexport function indexof (value, search) {\n\treturn value.indexOf(search)\n}\n\n/**\n * @param {string} value\n * @param {number} index\n * @return {number}\n */\nexport function charat (value, index) {\n\treturn value.charCodeAt(index) | 0\n}\n\n/**\n * @param {string} value\n * @param {number} begin\n * @param {number} end\n * @return {string}\n */\nexport function substr (value, begin, end) {\n\treturn value.slice(begin, end)\n}\n\n/**\n * @param {string} value\n * @return {number}\n */\nexport function strlen (value) {\n\treturn value.length\n}\n\n/**\n * @param {any[]} value\n * @return {number}\n */\nexport function sizeof (value) {\n\treturn value.length\n}\n\n/**\n * @param {any} value\n * @param {any[]} array\n * @return {any}\n */\nexport function append (value, array) {\n\treturn array.push(value), value\n}\n\n/**\n * @param {string[]} array\n * @param {function} callback\n * @return {string}\n */\nexport function combine (array, callback) {\n\treturn array.map(callback).join('')\n}\n","const tab = 9 /* `\\t` */\nconst space = 32 /* ` ` */\n\n/**\n * Remove initial and final spaces and tabs at the line breaks in `value`.\n * Does not trim initial and final spaces and tabs of the value itself.\n *\n * @param {string} value\n *   Value to trim.\n * @returns {string}\n *   Trimmed value.\n */\nexport function trimLines(value) {\n  const source = String(value)\n  const search = /\\r?\\n|\\r/g\n  let match = search.exec(source)\n  let last = 0\n  /** @type {Array<string>} */\n  const lines = []\n\n  while (match) {\n    lines.push(\n      trimLine(source.slice(last, match.index), last > 0, true),\n      match[0]\n    )\n\n    last = match.index + match[0].length\n    match = search.exec(source)\n  }\n\n  lines.push(trimLine(source.slice(last), last > 0, false))\n\n  return lines.join('')\n}\n\n/**\n * @param {string} value\n *   Line to trim.\n * @param {boolean} start\n *   Whether to trim the start of the line.\n * @param {boolean} end\n *   Whether to trim the end of the line.\n * @returns {string}\n *   Trimmed line.\n */\nfunction trimLine(value, start, end) {\n  let startIndex = 0\n  let endIndex = value.length\n\n  if (start) {\n    let code = value.codePointAt(startIndex)\n\n    while (code === tab || code === space) {\n      startIndex++\n      code = value.codePointAt(startIndex)\n    }\n  }\n\n  if (end) {\n    let code = value.codePointAt(endIndex - 1)\n\n    while (code === tab || code === space) {\n      endIndex--\n      code = value.codePointAt(endIndex - 1)\n    }\n  }\n\n  return endIndex > startIndex ? value.slice(startIndex, endIndex) : ''\n}\n","export default function isPlainObject(value) {\n\tif (typeof value !== 'object' || value === null) {\n\t\treturn false;\n\t}\n\n\tconst prototype = Object.getPrototypeOf(value);\n\treturn (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);\n}\n","/**\n * @typedef {(error?: Error|null|undefined, ...output: Array<any>) => void} Callback\n * @typedef {(...input: Array<any>) => any} Middleware\n *\n * @typedef {(...input: Array<any>) => void} Run\n *   Call all middleware.\n * @typedef {(fn: Middleware) => Pipeline} Use\n *   Add `fn` (middleware) to the list.\n * @typedef {{run: Run, use: Use}} Pipeline\n *   Middleware.\n */\n\n/**\n * Create new middleware.\n *\n * @returns {Pipeline}\n */\nexport function trough() {\n  /** @type {Array<Middleware>} */\n  const fns = []\n  /** @type {Pipeline} */\n  const pipeline = {run, use}\n\n  return pipeline\n\n  /** @type {Run} */\n  function run(...values) {\n    let middlewareIndex = -1\n    /** @type {Callback} */\n    const callback = values.pop()\n\n    if (typeof callback !== 'function') {\n      throw new TypeError('Expected function as last argument, not ' + callback)\n    }\n\n    next(null, ...values)\n\n    /**\n     * Run the next `fn`, or were done.\n     *\n     * @param {Error|null|undefined} error\n     * @param {Array<any>} output\n     */\n    function next(error, ...output) {\n      const fn = fns[++middlewareIndex]\n      let index = -1\n\n      if (error) {\n        callback(error)\n        return\n      }\n\n      // Copy non-nullish input into values.\n      while (++index < values.length) {\n        if (output[index] === null || output[index] === undefined) {\n          output[index] = values[index]\n        }\n      }\n\n      // Save the newly created `output` for the next call.\n      values = output\n\n      // Next or done.\n      if (fn) {\n        wrap(fn, next)(...output)\n      } else {\n        callback(null, ...output)\n      }\n    }\n  }\n\n  /** @type {Use} */\n  function use(middelware) {\n    if (typeof middelware !== 'function') {\n      throw new TypeError(\n        'Expected `middelware` to be a function, not ' + middelware\n      )\n    }\n\n    fns.push(middelware)\n    return pipeline\n  }\n}\n\n/**\n * Wrap `middleware`.\n * Can be sync or async; return a promise, receive a callback, or return new\n * values and errors.\n *\n * @param {Middleware} middleware\n * @param {Callback} callback\n */\nexport function wrap(middleware, callback) {\n  /** @type {boolean} */\n  let called\n\n  return wrapped\n\n  /**\n   * Call `middleware`.\n   * @this {any}\n   * @param {Array<any>} parameters\n   * @returns {void}\n   */\n  function wrapped(...parameters) {\n    const fnExpectsCallback = middleware.length > parameters.length\n    /** @type {any} */\n    let result\n\n    if (fnExpectsCallback) {\n      parameters.push(done)\n    }\n\n    try {\n      result = middleware.apply(this, parameters)\n    } catch (error) {\n      const exception = /** @type {Error} */ (error)\n\n      // Well, this is quite the pickle.\n      // `middleware` received a callback and called it synchronously, but that\n      // threw an error.\n      // The only thing left to do is to throw the thing instead.\n      if (fnExpectsCallback && called) {\n        throw exception\n      }\n\n      return done(exception)\n    }\n\n    if (!fnExpectsCallback) {\n      if (result instanceof Promise) {\n        result.then(then, done)\n      } else if (result instanceof Error) {\n        done(result)\n      } else {\n        then(result)\n      }\n    }\n  }\n\n  /**\n   * Call `callback`, only once.\n   * @type {Callback}\n   */\n  function done(error, ...output) {\n    if (!called) {\n      called = true\n      callback(error, ...output)\n    }\n  }\n\n  /**\n   * Call `done` with one value.\n   *\n   * @param {any} [value]\n   */\n  function then(value) {\n    done(null, value)\n  }\n}\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('vfile').VFileCompatible} VFileCompatible\n * @typedef {import('vfile').VFileValue} VFileValue\n * @typedef {import('..').Processor} Processor\n * @typedef {import('..').Plugin} Plugin\n * @typedef {import('..').Preset} Preset\n * @typedef {import('..').Pluggable} Pluggable\n * @typedef {import('..').PluggableList} PluggableList\n * @typedef {import('..').Transformer} Transformer\n * @typedef {import('..').Parser} Parser\n * @typedef {import('..').Compiler} Compiler\n * @typedef {import('..').RunCallback} RunCallback\n * @typedef {import('..').ProcessCallback} ProcessCallback\n *\n * @typedef Context\n * @property {Node} tree\n * @property {VFile} file\n */\n\nimport {bail} from 'bail'\nimport isBuffer from 'is-buffer'\nimport extend from 'extend'\nimport isPlainObj from 'is-plain-obj'\nimport {trough} from 'trough'\nimport {VFile} from 'vfile'\n\n// Expose a frozen processor.\nexport const unified = base().freeze()\n\nconst own = {}.hasOwnProperty\n\n// Function to create the first processor.\n/**\n * @returns {Processor}\n */\nfunction base() {\n  const transformers = trough()\n  /** @type {Processor['attachers']} */\n  const attachers = []\n  /** @type {Record<string, unknown>} */\n  let namespace = {}\n  /** @type {boolean|undefined} */\n  let frozen\n  let freezeIndex = -1\n\n  // Data management.\n  // @ts-expect-error: overloads are handled.\n  processor.data = data\n  processor.Parser = undefined\n  processor.Compiler = undefined\n\n  // Lock.\n  processor.freeze = freeze\n\n  // Plugins.\n  processor.attachers = attachers\n  // @ts-expect-error: overloads are handled.\n  processor.use = use\n\n  // API.\n  processor.parse = parse\n  processor.stringify = stringify\n  // @ts-expect-error: overloads are handled.\n  processor.run = run\n  processor.runSync = runSync\n  // @ts-expect-error: overloads are handled.\n  processor.process = process\n  processor.processSync = processSync\n\n  // Expose.\n  return processor\n\n  // Create a new processor based on the processor in the current scope.\n  /** @type {Processor} */\n  function processor() {\n    const destination = base()\n    let index = -1\n\n    while (++index < attachers.length) {\n      destination.use(...attachers[index])\n    }\n\n    destination.data(extend(true, {}, namespace))\n\n    return destination\n  }\n\n  /**\n   * @param {string|Record<string, unknown>} [key]\n   * @param {unknown} [value]\n   * @returns {unknown}\n   */\n  function data(key, value) {\n    if (typeof key === 'string') {\n      // Set `key`.\n      if (arguments.length === 2) {\n        assertUnfrozen('data', frozen)\n        namespace[key] = value\n        return processor\n      }\n\n      // Get `key`.\n      return (own.call(namespace, key) && namespace[key]) || null\n    }\n\n    // Set space.\n    if (key) {\n      assertUnfrozen('data', frozen)\n      namespace = key\n      return processor\n    }\n\n    // Get space.\n    return namespace\n  }\n\n  /** @type {Processor['freeze']} */\n  function freeze() {\n    if (frozen) {\n      return processor\n    }\n\n    while (++freezeIndex < attachers.length) {\n      const [attacher, ...options] = attachers[freezeIndex]\n\n      if (options[0] === false) {\n        continue\n      }\n\n      if (options[0] === true) {\n        options[0] = undefined\n      }\n\n      /** @type {Transformer|void} */\n      const transformer = attacher.call(processor, ...options)\n\n      if (typeof transformer === 'function') {\n        transformers.use(transformer)\n      }\n    }\n\n    frozen = true\n    freezeIndex = Number.POSITIVE_INFINITY\n\n    return processor\n  }\n\n  /**\n   * @param {Pluggable|null|undefined} [value]\n   * @param {...unknown} options\n   * @returns {Processor}\n   */\n  function use(value, ...options) {\n    /** @type {Record<string, unknown>|undefined} */\n    let settings\n\n    assertUnfrozen('use', frozen)\n\n    if (value === null || value === undefined) {\n      // Empty.\n    } else if (typeof value === 'function') {\n      addPlugin(value, ...options)\n    } else if (typeof value === 'object') {\n      if (Array.isArray(value)) {\n        addList(value)\n      } else {\n        addPreset(value)\n      }\n    } else {\n      throw new TypeError('Expected usable value, not `' + value + '`')\n    }\n\n    if (settings) {\n      namespace.settings = Object.assign(namespace.settings || {}, settings)\n    }\n\n    return processor\n\n    /**\n     * @param {import('..').Pluggable<unknown[]>} value\n     * @returns {void}\n     */\n    function add(value) {\n      if (typeof value === 'function') {\n        addPlugin(value)\n      } else if (typeof value === 'object') {\n        if (Array.isArray(value)) {\n          const [plugin, ...options] = value\n          addPlugin(plugin, ...options)\n        } else {\n          addPreset(value)\n        }\n      } else {\n        throw new TypeError('Expected usable value, not `' + value + '`')\n      }\n    }\n\n    /**\n     * @param {Preset} result\n     * @returns {void}\n     */\n    function addPreset(result) {\n      addList(result.plugins)\n\n      if (result.settings) {\n        settings = Object.assign(settings || {}, result.settings)\n      }\n    }\n\n    /**\n     * @param {PluggableList|null|undefined} [plugins]\n     * @returns {void}\n     */\n    function addList(plugins) {\n      let index = -1\n\n      if (plugins === null || plugins === undefined) {\n        // Empty.\n      } else if (Array.isArray(plugins)) {\n        while (++index < plugins.length) {\n          const thing = plugins[index]\n          add(thing)\n        }\n      } else {\n        throw new TypeError('Expected a list of plugins, not `' + plugins + '`')\n      }\n    }\n\n    /**\n     * @param {Plugin} plugin\n     * @param {...unknown} [value]\n     * @returns {void}\n     */\n    function addPlugin(plugin, value) {\n      let index = -1\n      /** @type {Processor['attachers'][number]|undefined} */\n      let entry\n\n      while (++index < attachers.length) {\n        if (attachers[index][0] === plugin) {\n          entry = attachers[index]\n          break\n        }\n      }\n\n      if (entry) {\n        if (isPlainObj(entry[1]) && isPlainObj(value)) {\n          value = extend(true, entry[1], value)\n        }\n\n        entry[1] = value\n      } else {\n        // @ts-expect-error: fine.\n        attachers.push([...arguments])\n      }\n    }\n  }\n\n  /** @type {Processor['parse']} */\n  function parse(doc) {\n    processor.freeze()\n    const file = vfile(doc)\n    const Parser = processor.Parser\n    assertParser('parse', Parser)\n\n    if (newable(Parser, 'parse')) {\n      // @ts-expect-error: `newable` checks this.\n      return new Parser(String(file), file).parse()\n    }\n\n    // @ts-expect-error: `newable` checks this.\n    return Parser(String(file), file) // eslint-disable-line new-cap\n  }\n\n  /** @type {Processor['stringify']} */\n  function stringify(node, doc) {\n    processor.freeze()\n    const file = vfile(doc)\n    const Compiler = processor.Compiler\n    assertCompiler('stringify', Compiler)\n    assertNode(node)\n\n    if (newable(Compiler, 'compile')) {\n      // @ts-expect-error: `newable` checks this.\n      return new Compiler(node, file).compile()\n    }\n\n    // @ts-expect-error: `newable` checks this.\n    return Compiler(node, file) // eslint-disable-line new-cap\n  }\n\n  /**\n   * @param {Node} node\n   * @param {VFileCompatible|RunCallback} [doc]\n   * @param {RunCallback} [callback]\n   * @returns {Promise<Node>|void}\n   */\n  function run(node, doc, callback) {\n    assertNode(node)\n    processor.freeze()\n\n    if (!callback && typeof doc === 'function') {\n      callback = doc\n      doc = undefined\n    }\n\n    if (!callback) {\n      return new Promise(executor)\n    }\n\n    executor(null, callback)\n\n    /**\n     * @param {null|((node: Node) => void)} resolve\n     * @param {(error: Error) => void} reject\n     * @returns {void}\n     */\n    function executor(resolve, reject) {\n      // @ts-expect-error: `doc` cant be a callback anymore, we checked.\n      transformers.run(node, vfile(doc), done)\n\n      /**\n       * @param {Error|null} error\n       * @param {Node} tree\n       * @param {VFile} file\n       * @returns {void}\n       */\n      function done(error, tree, file) {\n        tree = tree || node\n        if (error) {\n          reject(error)\n        } else if (resolve) {\n          resolve(tree)\n        } else {\n          // @ts-expect-error: `callback` is defined if `resolve` is not.\n          callback(null, tree, file)\n        }\n      }\n    }\n  }\n\n  /** @type {Processor['runSync']} */\n  function runSync(node, file) {\n    /** @type {Node|undefined} */\n    let result\n    /** @type {boolean|undefined} */\n    let complete\n\n    processor.run(node, file, done)\n\n    assertDone('runSync', 'run', complete)\n\n    // @ts-expect-error: we either bailed on an error or have a tree.\n    return result\n\n    /**\n     * @param {Error|null} [error]\n     * @param {Node} [tree]\n     * @returns {void}\n     */\n    function done(error, tree) {\n      bail(error)\n      result = tree\n      complete = true\n    }\n  }\n\n  /**\n   * @param {VFileCompatible} doc\n   * @param {ProcessCallback} [callback]\n   * @returns {Promise<VFile>|undefined}\n   */\n  function process(doc, callback) {\n    processor.freeze()\n    assertParser('process', processor.Parser)\n    assertCompiler('process', processor.Compiler)\n\n    if (!callback) {\n      return new Promise(executor)\n    }\n\n    executor(null, callback)\n\n    /**\n     * @param {null|((file: VFile) => void)} resolve\n     * @param {(error?: Error|null|undefined) => void} reject\n     * @returns {void}\n     */\n    function executor(resolve, reject) {\n      const file = vfile(doc)\n\n      processor.run(processor.parse(file), file, (error, tree, file) => {\n        if (error || !tree || !file) {\n          done(error)\n        } else {\n          /** @type {unknown} */\n          const result = processor.stringify(tree, file)\n\n          if (result === undefined || result === null) {\n            // Empty.\n          } else if (looksLikeAVFileValue(result)) {\n            file.value = result\n          } else {\n            file.result = result\n          }\n\n          done(error, file)\n        }\n      })\n\n      /**\n       * @param {Error|null|undefined} [error]\n       * @param {VFile|undefined} [file]\n       * @returns {void}\n       */\n      function done(error, file) {\n        if (error || !file) {\n          reject(error)\n        } else if (resolve) {\n          resolve(file)\n        } else {\n          // @ts-expect-error: `callback` is defined if `resolve` is not.\n          callback(null, file)\n        }\n      }\n    }\n  }\n\n  /** @type {Processor['processSync']} */\n  function processSync(doc) {\n    /** @type {boolean|undefined} */\n    let complete\n\n    processor.freeze()\n    assertParser('processSync', processor.Parser)\n    assertCompiler('processSync', processor.Compiler)\n\n    const file = vfile(doc)\n\n    processor.process(file, done)\n\n    assertDone('processSync', 'process', complete)\n\n    return file\n\n    /**\n     * @param {Error|null|undefined} [error]\n     * @returns {void}\n     */\n    function done(error) {\n      complete = true\n      bail(error)\n    }\n  }\n}\n\n/**\n * Check if `value` is a constructor.\n *\n * @param {unknown} value\n * @param {string} name\n * @returns {boolean}\n */\nfunction newable(value, name) {\n  return (\n    typeof value === 'function' &&\n    // Prototypes do exist.\n    // type-coverage:ignore-next-line\n    value.prototype &&\n    // A function with keys in its prototype is probably a constructor.\n    // Classes prototype methods are not enumerable, so we check if some value\n    // exists in the prototype.\n    // type-coverage:ignore-next-line\n    (keys(value.prototype) || name in value.prototype)\n  )\n}\n\n/**\n * Check if `value` is an object with keys.\n *\n * @param {Record<string, unknown>} value\n * @returns {boolean}\n */\nfunction keys(value) {\n  /** @type {string} */\n  let key\n\n  for (key in value) {\n    if (own.call(value, key)) {\n      return true\n    }\n  }\n\n  return false\n}\n\n/**\n * Assert a parser is available.\n *\n * @param {string} name\n * @param {unknown} value\n * @returns {asserts value is Parser}\n */\nfunction assertParser(name, value) {\n  if (typeof value !== 'function') {\n    throw new TypeError('Cannot `' + name + '` without `Parser`')\n  }\n}\n\n/**\n * Assert a compiler is available.\n *\n * @param {string} name\n * @param {unknown} value\n * @returns {asserts value is Compiler}\n */\nfunction assertCompiler(name, value) {\n  if (typeof value !== 'function') {\n    throw new TypeError('Cannot `' + name + '` without `Compiler`')\n  }\n}\n\n/**\n * Assert the processor is not frozen.\n *\n * @param {string} name\n * @param {unknown} frozen\n * @returns {asserts frozen is false}\n */\nfunction assertUnfrozen(name, frozen) {\n  if (frozen) {\n    throw new Error(\n      'Cannot call `' +\n        name +\n        '` on a frozen processor.\\nCreate a new processor first, by calling it: use `processor()` instead of `processor`.'\n    )\n  }\n}\n\n/**\n * Assert `node` is a unist node.\n *\n * @param {unknown} node\n * @returns {asserts node is Node}\n */\nfunction assertNode(node) {\n  // `isPlainObj` unfortunately uses `any` instead of `unknown`.\n  // type-coverage:ignore-next-line\n  if (!isPlainObj(node) || typeof node.type !== 'string') {\n    throw new TypeError('Expected node, got `' + node + '`')\n    // Fine.\n  }\n}\n\n/**\n * Assert that `complete` is `true`.\n *\n * @param {string} name\n * @param {string} asyncName\n * @param {unknown} complete\n * @returns {asserts complete is true}\n */\nfunction assertDone(name, asyncName, complete) {\n  if (!complete) {\n    throw new Error(\n      '`' + name + '` finished async. Use `' + asyncName + '` instead'\n    )\n  }\n}\n\n/**\n * @param {VFileCompatible} [value]\n * @returns {VFile}\n */\nfunction vfile(value) {\n  return looksLikeAVFile(value) ? value : new VFile(value)\n}\n\n/**\n * @param {VFileCompatible} [value]\n * @returns {value is VFile}\n */\nfunction looksLikeAVFile(value) {\n  return Boolean(\n    value &&\n      typeof value === 'object' &&\n      'message' in value &&\n      'messages' in value\n  )\n}\n\n/**\n * @param {unknown} [value]\n * @returns {value is VFileValue}\n */\nfunction looksLikeAVFileValue(value) {\n  return typeof value === 'string' || isBuffer(value)\n}\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n * @typedef {import('unist').Literal} Literal\n * @typedef {Object.<string, unknown>} Props\n * @typedef {Array.<Node>|string} ChildrenOrValue\n *\n * @typedef {(<T extends string, P extends Record<string, unknown>, C extends Node[]>(type: T, props: P, children: C) => {type: T, children: C} & P)} BuildParentWithProps\n * @typedef {(<T extends string, P extends Record<string, unknown>>(type: T, props: P, value: string) => {type: T, value: string} & P)} BuildLiteralWithProps\n * @typedef {(<T extends string, P extends Record<string, unknown>>(type: T, props: P) => {type: T} & P)} BuildVoidWithProps\n * @typedef {(<T extends string, C extends Node[]>(type: T, children: C) => {type: T, children: C})} BuildParent\n * @typedef {(<T extends string>(type: T, value: string) => {type: T, value: string})} BuildLiteral\n * @typedef {(<T extends string>(type: T) => {type: T})} BuildVoid\n */\n\nexport var u = /**\n * @type {BuildVoid & BuildVoidWithProps & BuildLiteral & BuildLiteralWithProps & BuildParent & BuildParentWithProps}\n */ (\n  /**\n   * @param {string} type Type of node\n   * @param {Props|ChildrenOrValue} [props] Additional properties for node (or `children` or `value`)\n   * @param {ChildrenOrValue} [value] `children` or `value` of node\n   * @returns {Node}\n   */\n  function (type, props, value) {\n    /** @type {Node} */\n    var node = {type: String(type)}\n\n    if (\n      (value === undefined || value === null) &&\n      (typeof props === 'string' || Array.isArray(props))\n    ) {\n      value = props\n    } else {\n      Object.assign(node, props)\n    }\n\n    if (Array.isArray(value)) {\n      node.children = value\n    } else if (value !== undefined && value !== null) {\n      node.value = String(value)\n    }\n\n    return node\n  }\n)\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n *\n * @typedef {import('unist-util-is').Type} Type\n * @typedef {import('unist-util-is').Props} Props\n * @typedef {import('unist-util-is').TestFunctionAnything} TestFunctionAnything\n */\n\nimport {convert} from 'unist-util-is'\n\nexport var findAfter =\n  /**\n   * @type {(\n   *  (<T extends Node>(node: Parent, index: Node|number, test: T['type']|Partial<T>|import('unist-util-is').TestFunctionPredicate<T>|Array.<T['type']|Partial<T>|import('unist-util-is').TestFunctionPredicate<T>>) => T|null) &\n   *  ((node: Parent, index: Node|number, test?: null|undefined|Type|Props|TestFunctionAnything|Array<Type|Props|TestFunctionAnything>) => Node|null)\n   * )}\n   */\n  (\n    /**\n     * @param {Parent} parent Parent node\n     * @param {Node|number} index Child of `parent`, or its index\n     * @param {null|undefined|Type|Props|TestFunctionAnything|Array<Type|Props|TestFunctionAnything>} [test] is-compatible test (such as a type)\n     * @returns {Node|null}\n     */\n    function (parent, index, test) {\n      var is = convert(test)\n\n      if (!parent || !parent.type || !parent.children) {\n        throw new Error('Expected parent node')\n      }\n\n      if (typeof index === 'number') {\n        if (index < 0 || index === Number.POSITIVE_INFINITY) {\n          throw new Error('Expected positive finite number as index')\n        }\n      } else {\n        index = parent.children.indexOf(index)\n\n        if (index < 0) {\n          throw new Error('Expected child node or index')\n        }\n      }\n\n      while (++index < parent.children.length) {\n        if (is(parent.children[index], index, parent)) {\n          return parent.children[index]\n        }\n      }\n\n      return null\n    }\n  )\n","/**\n * @typedef {Object} PointLike\n * @property {number} [line]\n * @property {number} [column]\n * @property {number} [offset]\n *\n * @typedef {Object} PositionLike\n * @property {PointLike} [start]\n * @property {PointLike} [end]\n *\n * @typedef {Object} NodeLike\n * @property {PositionLike} [position]\n */\n\n/**\n * Check if `node` is *generated*.\n *\n * @param {NodeLike} [node]\n * @returns {boolean}\n */\nexport function generated(node) {\n  return (\n    !node ||\n    !node.position ||\n    !node.position.start ||\n    !node.position.start.line ||\n    !node.position.start.column ||\n    !node.position.end ||\n    !node.position.end.line ||\n    !node.position.end.column\n  )\n}\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n *\n * @typedef {string} Type\n * @typedef {Object<string, unknown>} Props\n *\n * @typedef {null|undefined|Type|Props|TestFunctionAnything|Array.<Type|Props|TestFunctionAnything>} Test\n */\n\n/**\n * Check if a node passes a test\n *\n * @callback TestFunctionAnything\n * @param {Node} node\n * @param {number|null|undefined} [index]\n * @param {Parent|null|undefined} [parent]\n * @returns {boolean|void}\n */\n\n/**\n * Check if a node passes a certain node test\n *\n * @template {Node} X\n * @callback TestFunctionPredicate\n * @param {Node} node\n * @param {number|null|undefined} [index]\n * @param {Parent|null|undefined} [parent]\n * @returns {node is X}\n */\n\n/**\n * @callback AssertAnything\n * @param {unknown} [node]\n * @param {number|null|undefined} [index]\n * @param {Parent|null|undefined} [parent]\n * @returns {boolean}\n */\n\n/**\n * Check if a node passes a certain node test\n *\n * @template {Node} Y\n * @callback AssertPredicate\n * @param {unknown} [node]\n * @param {number|null|undefined} [index]\n * @param {Parent|null|undefined} [parent]\n * @returns {node is Y}\n */\n\nexport const is =\n  /**\n   * Check if a node passes a test.\n   * When a `parent` node is known the `index` of node should also be given.\n   *\n   * @type {(\n   *   (<T extends Node>(node: unknown, test: T['type']|Partial<T>|TestFunctionPredicate<T>|Array.<T['type']|Partial<T>|TestFunctionPredicate<T>>, index?: number|null|undefined, parent?: Parent|null|undefined, context?: unknown) => node is T) &\n   *   ((node?: unknown, test?: Test, index?: number|null|undefined, parent?: Parent|null|undefined, context?: unknown) => boolean)\n   * )}\n   */\n  (\n    /**\n     * Check if a node passes a test.\n     * When a `parent` node is known the `index` of node should also be given.\n     *\n     * @param {unknown} [node] Node to check\n     * @param {Test} [test]\n     * When nullish, checks if `node` is a `Node`.\n     * When `string`, works like passing `function (node) {return node.type === test}`.\n     * When `function` checks if function passed the node is true.\n     * When `object`, checks that all keys in test are in node, and that they have (strictly) equal values.\n     * When `array`, checks any one of the subtests pass.\n     * @param {number|null|undefined} [index] Position of `node` in `parent`\n     * @param {Parent|null|undefined} [parent] Parent of `node`\n     * @param {unknown} [context] Context object to invoke `test` with\n     * @returns {boolean} Whether test passed and `node` is a `Node` (object with `type` set to non-empty `string`).\n     */\n    // eslint-disable-next-line max-params\n    function is(node, test, index, parent, context) {\n      const check = convert(test)\n\n      if (\n        index !== undefined &&\n        index !== null &&\n        (typeof index !== 'number' ||\n          index < 0 ||\n          index === Number.POSITIVE_INFINITY)\n      ) {\n        throw new Error('Expected positive finite index')\n      }\n\n      if (\n        parent !== undefined &&\n        parent !== null &&\n        (!is(parent) || !parent.children)\n      ) {\n        throw new Error('Expected parent node')\n      }\n\n      if (\n        (parent === undefined || parent === null) !==\n        (index === undefined || index === null)\n      ) {\n        throw new Error('Expected both parent and index')\n      }\n\n      // @ts-expect-error Looks like a node.\n      return node && node.type && typeof node.type === 'string'\n        ? Boolean(check.call(context, node, index, parent))\n        : false\n    }\n  )\n\nexport const convert =\n  /**\n   * @type {(\n   *   (<T extends Node>(test: T['type']|Partial<T>|TestFunctionPredicate<T>) => AssertPredicate<T>) &\n   *   ((test?: Test) => AssertAnything)\n   * )}\n   */\n  (\n    /**\n     * Generate an assertion from a check.\n     * @param {Test} [test]\n     * When nullish, checks if `node` is a `Node`.\n     * When `string`, works like passing `function (node) {return node.type === test}`.\n     * When `function` checks if function passed the node is true.\n     * When `object`, checks that all keys in test are in node, and that they have (strictly) equal values.\n     * When `array`, checks any one of the subtests pass.\n     * @returns {AssertAnything}\n     */\n    function (test) {\n      if (test === undefined || test === null) {\n        return ok\n      }\n\n      if (typeof test === 'string') {\n        return typeFactory(test)\n      }\n\n      if (typeof test === 'object') {\n        return Array.isArray(test) ? anyFactory(test) : propsFactory(test)\n      }\n\n      if (typeof test === 'function') {\n        return castFactory(test)\n      }\n\n      throw new Error('Expected function, string, or object as test')\n    }\n  )\n/**\n * @param {Array.<Type|Props|TestFunctionAnything>} tests\n * @returns {AssertAnything}\n */\nfunction anyFactory(tests) {\n  /** @type {Array.<AssertAnything>} */\n  const checks = []\n  let index = -1\n\n  while (++index < tests.length) {\n    checks[index] = convert(tests[index])\n  }\n\n  return castFactory(any)\n\n  /**\n   * @this {unknown}\n   * @param {unknown[]} parameters\n   * @returns {boolean}\n   */\n  function any(...parameters) {\n    let index = -1\n\n    while (++index < checks.length) {\n      if (checks[index].call(this, ...parameters)) return true\n    }\n\n    return false\n  }\n}\n\n/**\n * Utility to assert each property in `test` is represented in `node`, and each\n * values are strictly equal.\n *\n * @param {Props} check\n * @returns {AssertAnything}\n */\nfunction propsFactory(check) {\n  return castFactory(all)\n\n  /**\n   * @param {Node} node\n   * @returns {boolean}\n   */\n  function all(node) {\n    /** @type {string} */\n    let key\n\n    for (key in check) {\n      // @ts-expect-error: hush, it sure works as an index.\n      if (node[key] !== check[key]) return false\n    }\n\n    return true\n  }\n}\n\n/**\n * Utility to convert a string into a function which checks a given nodes type\n * for said string.\n *\n * @param {Type} check\n * @returns {AssertAnything}\n */\nfunction typeFactory(check) {\n  return castFactory(type)\n\n  /**\n   * @param {Node} node\n   */\n  function type(node) {\n    return node && node.type === check\n  }\n}\n\n/**\n * Utility to convert a string into a function which checks a given nodes type\n * for said string.\n * @param {TestFunctionAnything} check\n * @returns {AssertAnything}\n */\nfunction castFactory(check) {\n  return assertion\n\n  /**\n   * @this {unknown}\n   * @param {Array.<unknown>} parameters\n   * @returns {boolean}\n   */\n  function assertion(...parameters) {\n    // @ts-expect-error: spreading is fine.\n    return Boolean(check.call(this, ...parameters))\n  }\n}\n\n// Utility to return true.\nfunction ok() {\n  return true\n}\n","/**\n * @typedef {import('unist').Position} Position\n * @typedef {import('unist').Node} Node\n * @typedef {Record<string, unknown> & {type: string, position?: PositionLike|undefined}} NodeLike\n * @typedef {import('unist').Point} Point\n *\n * @typedef {Partial<Point>} PointLike\n *\n * @typedef PositionLike\n * @property {PointLike} [start]\n * @property {PointLike} [end]\n */\n\nexport const pointStart = point('start')\nexport const pointEnd = point('end')\n\n/**\n * Get the positional info of `node`.\n *\n * @param {NodeLike|Node} [node]\n * @returns {Position}\n */\nexport function position(node) {\n  return {start: pointStart(node), end: pointEnd(node)}\n}\n\n/**\n * Get the positional info of `node`.\n *\n * @param {'start'|'end'} type\n */\nfunction point(type) {\n  return point\n\n  /**\n   * Get the positional info of `node`.\n   *\n   * @param {NodeLike|Node} [node]\n   * @returns {Point}\n   */\n  function point(node) {\n    const point = (node && node.position && node.position[type]) || {}\n\n    return {\n      line: point.line || null,\n      column: point.column || null,\n      offset: point.offset > -1 ? point.offset : null\n    }\n  }\n}\n","/**\n * @typedef {import('unist').Node} Node\n */\n\nimport {visit} from 'unist-util-visit'\n\n/**\n * Utility to remove positions from a tree\n *\n * @param node The unist tree\n * @param force if `force` is given, uses `delete`, otherwise, sets positions to `undefined`.\n * @returns The same node, but either with `position: undefined` or w/o `position` fields\n */\nexport const removePosition =\n  /**\n   * @type {(\n   *   (<Tree extends Node>(tree: Tree, force?: false) => Tree) &\n   *   (<Tree extends Node>(tree: Tree, force: true) => Tree)\n   * )}\n   */\n  (\n    /**\n     * @template {Node} Tree\n     * @param {Tree} node\n     * @param {boolean} [force=false]\n     * @returns {Tree}\n     */\n    function (node, force) {\n      visit(node, remove)\n\n      // @ts-ignore hush TS, we know what were doing.\n      return node\n\n      /**\n       * @param {Node} node the unist tree\n       */\n      function remove(node) {\n        if (force) {\n          delete node.position\n        } else {\n          node.position = undefined\n        }\n      }\n    }\n  )\n","/**\n * @typedef {import('unist').Point} Point\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Position} Position\n * @typedef {object & {type: string, position?: Position|undefined}} NodeLike\n */\n\n/**\n * Stringify one point, a position (start and end points), or a nodes\n * positional information.\n *\n * @param {Node|NodeLike|Position|Point|null} [value]\n * @returns {string}\n */\nexport function stringifyPosition(value) {\n  // Nothing.\n  if (!value || typeof value !== 'object') {\n    return ''\n  }\n\n  // Node.\n  if ('position' in value || 'type' in value) {\n    return position(value.position)\n  }\n\n  // Position.\n  if ('start' in value || 'end' in value) {\n    return position(value)\n  }\n\n  // Point.\n  if ('line' in value || 'column' in value) {\n    return point(value)\n  }\n\n  // ?\n  return ''\n}\n\n/**\n * @param {Point|undefined} point\n * @returns {string}\n */\nfunction point(point) {\n  return index(point && point.line) + ':' + index(point && point.column)\n}\n\n/**\n * @param {Position|undefined} pos\n * @returns {string}\n */\nfunction position(pos) {\n  return point(pos && pos.start) + '-' + point(pos && pos.end)\n}\n\n/**\n * @param {number|undefined} value\n * @returns {number}\n */\nfunction index(value) {\n  return value && typeof value === 'number' ? value : 1\n}\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n * @typedef {import('unist-util-is').Test} Test\n * @typedef {import('./complex-types.js').Action} Action\n * @typedef {import('./complex-types.js').Index} Index\n * @typedef {import('./complex-types.js').ActionTuple} ActionTuple\n * @typedef {import('./complex-types.js').VisitorResult} VisitorResult\n * @typedef {import('./complex-types.js').Visitor} Visitor\n */\n\nimport {convert} from 'unist-util-is'\nimport {color} from './color.js'\n\n/**\n * Continue traversing as normal\n */\nexport const CONTINUE = true\n/**\n * Do not traverse this nodes children\n */\nexport const SKIP = 'skip'\n/**\n * Stop traversing immediately\n */\nexport const EXIT = false\n\n/**\n * Visit children of tree which pass test.\n *\n * @param tree\n *   Tree to walk\n * @param [test]\n *   `unist-util-is`-compatible test\n * @param visitor\n *   Function called for nodes that pass `test`.\n * @param [reverse=false]\n *   Traverse in reverse preorder (NRL) instead of preorder (NLR) (default).\n */\nexport const visitParents =\n  /**\n   * @type {(\n   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: import('./complex-types.js').BuildVisitor<Tree, Check>, reverse?: boolean) => void) &\n   *   (<Tree extends Node>(tree: Tree, visitor: import('./complex-types.js').BuildVisitor<Tree>, reverse?: boolean) => void)\n   * )}\n   */\n  (\n    /**\n     * @param {Node} tree\n     * @param {Test} test\n     * @param {import('./complex-types.js').Visitor<Node>} visitor\n     * @param {boolean} [reverse=false]\n     */\n    function (tree, test, visitor, reverse) {\n      if (typeof test === 'function' && typeof visitor !== 'function') {\n        reverse = visitor\n        // @ts-expect-error no visitor given, so `visitor` is test.\n        visitor = test\n        test = null\n      }\n\n      const is = convert(test)\n      const step = reverse ? -1 : 1\n\n      factory(tree, null, [])()\n\n      /**\n       * @param {Node} node\n       * @param {number?} index\n       * @param {Array<Parent>} parents\n       */\n      function factory(node, index, parents) {\n        /** @type {Record<string, unknown>} */\n        // @ts-expect-error: hush\n        const value = typeof node === 'object' && node !== null ? node : {}\n        /** @type {string|undefined} */\n        let name\n\n        if (typeof value.type === 'string') {\n          name =\n            typeof value.tagName === 'string'\n              ? value.tagName\n              : typeof value.name === 'string'\n              ? value.name\n              : undefined\n\n          Object.defineProperty(visit, 'name', {\n            value:\n              'node (' +\n              color(value.type + (name ? '<' + name + '>' : '')) +\n              ')'\n          })\n        }\n\n        return visit\n\n        function visit() {\n          /** @type {ActionTuple} */\n          let result = []\n          /** @type {ActionTuple} */\n          let subresult\n          /** @type {number} */\n          let offset\n          /** @type {Array<Parent>} */\n          let grandparents\n\n          if (!test || is(node, index, parents[parents.length - 1] || null)) {\n            result = toResult(visitor(node, parents))\n\n            if (result[0] === EXIT) {\n              return result\n            }\n          }\n\n          // @ts-expect-error looks like a parent.\n          if (node.children && result[0] !== SKIP) {\n            // @ts-expect-error looks like a parent.\n            offset = (reverse ? node.children.length : -1) + step\n            // @ts-expect-error looks like a parent.\n            grandparents = parents.concat(node)\n\n            // @ts-expect-error looks like a parent.\n            while (offset > -1 && offset < node.children.length) {\n              // @ts-expect-error looks like a parent.\n              subresult = factory(node.children[offset], offset, grandparents)()\n\n              if (subresult[0] === EXIT) {\n                return subresult\n              }\n\n              offset =\n                typeof subresult[1] === 'number' ? subresult[1] : offset + step\n            }\n          }\n\n          return result\n        }\n      }\n    }\n  )\n\n/**\n * @param {VisitorResult} value\n * @returns {ActionTuple}\n */\nfunction toResult(value) {\n  if (Array.isArray(value)) {\n    return value\n  }\n\n  if (typeof value === 'number') {\n    return [CONTINUE, value]\n  }\n\n  return [value]\n}\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n * @typedef {import('unist-util-is').Test} Test\n * @typedef {import('unist-util-visit-parents').VisitorResult} VisitorResult\n * @typedef {import('./complex-types.js').Visitor} Visitor\n */\n\nimport {visitParents} from 'unist-util-visit-parents'\n\n/**\n * Visit children of tree which pass test.\n *\n * @param tree\n *   Tree to walk\n * @param [test]\n *   `unist-util-is`-compatible test\n * @param visitor\n *   Function called for nodes that pass `test`.\n * @param reverse\n *   Traverse in reverse preorder (NRL) instead of preorder (NLR) (default).\n */\nexport const visit =\n  /**\n   * @type {(\n   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: import('./complex-types.js').BuildVisitor<Tree, Check>, reverse?: boolean) => void) &\n   *   (<Tree extends Node>(tree: Tree, visitor: import('./complex-types.js').BuildVisitor<Tree>, reverse?: boolean) => void)\n   * )}\n   */\n  (\n    /**\n     * @param {Node} tree\n     * @param {Test} test\n     * @param {import('./complex-types.js').Visitor} visitor\n     * @param {boolean} [reverse]\n     */\n    function (tree, test, visitor, reverse) {\n      if (typeof test === 'function' && typeof visitor !== 'function') {\n        reverse = visitor\n        visitor = test\n        test = null\n      }\n\n      visitParents(tree, test, overload, reverse)\n\n      /**\n       * @param {Node} node\n       * @param {Array<Parent>} parents\n       */\n      function overload(node, parents) {\n        const parent = parents[parents.length - 1]\n        return visitor(\n          node,\n          parent ? parent.children.indexOf(node) : null,\n          parent\n        )\n      }\n    }\n  )\n\nexport {CONTINUE, EXIT, SKIP} from 'unist-util-visit-parents'\n","/**\n * @typedef {import('unist').Point} Point\n * @typedef {import('vfile').VFile} VFile\n *\n * @typedef {Pick<Point, 'line'|'column'>} PositionalPoint\n * @typedef {Required<Point>} FullPoint\n * @typedef {NonNullable<Point['offset']>} Offset\n */\n\n/**\n * Get transform functions for the given `document`.\n *\n * @param {string|Uint8Array|VFile} file\n */\nexport function location(file) {\n  var value = String(file)\n  /** @type {Array.<number>} */\n  var indices = []\n  var search = /\\r?\\n|\\r/g\n\n  while (search.test(value)) {\n    indices.push(search.lastIndex)\n  }\n\n  indices.push(value.length + 1)\n\n  return {toPoint, toOffset}\n\n  /**\n   * Get the line and column-based `point` for `offset` in the bound indices.\n   * Returns a point with `undefined` values when given invalid or out of bounds\n   * input.\n   *\n   * @param {Offset} offset\n   * @returns {FullPoint}\n   */\n  function toPoint(offset) {\n    var index = -1\n\n    if (offset > -1 && offset < indices[indices.length - 1]) {\n      while (++index < indices.length) {\n        if (indices[index] > offset) {\n          return {\n            line: index + 1,\n            column: offset - (indices[index - 1] || 0) + 1,\n            offset\n          }\n        }\n      }\n    }\n\n    return {line: undefined, column: undefined, offset: undefined}\n  }\n\n  /**\n   * Get the `offset` for a line and column-based `point` in the bound indices.\n   * Returns `-1` when given invalid or out of bounds input.\n   *\n   * @param {PositionalPoint} point\n   * @returns {Offset}\n   */\n  function toOffset(point) {\n    var line = point && point.line\n    var column = point && point.column\n    /** @type {number} */\n    var offset\n\n    if (\n      typeof line === 'number' &&\n      typeof column === 'number' &&\n      !Number.isNaN(line) &&\n      !Number.isNaN(column) &&\n      line - 1 in indices\n    ) {\n      offset = (indices[line - 2] || 0) + column - 1 || 0\n    }\n\n    return offset > -1 && offset < indices[indices.length - 1] ? offset : -1\n  }\n}\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Position} Position\n * @typedef {import('unist').Point} Point\n * @typedef {object & {type: string, position?: Position|undefined}} NodeLike\n */\n\nimport {stringifyPosition} from 'unist-util-stringify-position'\n\nexport class VFileMessage extends Error {\n  /**\n   * Create a message for `reason` at `place` from `origin`.\n   *\n   * When an error is passed in as `reason`, the `stack` is copied.\n   *\n   * @param {string|Error|VFileMessage} reason\n   *   Reason for message.\n   *   Uses the stack and message of the error if given.\n   * @param {Node|NodeLike|Position|Point} [place]\n   *   Place at which the message occurred in a file.\n   * @param {string} [origin]\n   *   Place in code the message originates from (example `'my-package:my-rule-name'`)\n   */\n  constructor(reason, place, origin) {\n    /** @type {[string|null, string|null]} */\n    const parts = [null, null]\n    /** @type {Position} */\n    let position = {\n      // @ts-expect-error: we always follows the structure of `position`.\n      start: {line: null, column: null},\n      // @ts-expect-error: \"\n      end: {line: null, column: null}\n    }\n\n    super()\n\n    if (typeof place === 'string') {\n      origin = place\n      place = undefined\n    }\n\n    if (typeof origin === 'string') {\n      const index = origin.indexOf(':')\n\n      if (index === -1) {\n        parts[1] = origin\n      } else {\n        parts[0] = origin.slice(0, index)\n        parts[1] = origin.slice(index + 1)\n      }\n    }\n\n    if (place) {\n      // Node.\n      if ('type' in place || 'position' in place) {\n        if (place.position) {\n          // @ts-expect-error: looks like a position.\n          position = place.position\n        }\n      }\n      // Position.\n      else if ('start' in place || 'end' in place) {\n        // @ts-expect-error: looks like a position.\n        position = place\n      }\n      // Point.\n      else if ('line' in place || 'column' in place) {\n        position.start = place\n      }\n    }\n\n    // Fields from `Error`\n    this.name = stringifyPosition(place) || '1:1'\n    /** @type {string} */\n    this.message = typeof reason === 'object' ? reason.message : reason\n    /** @type {string} */\n    this.stack = ''\n\n    if (typeof reason === 'object' && reason.stack) {\n      this.stack = reason.stack\n    }\n\n    /**\n     * Reason for message.\n     *\n     * @type {string}\n     */\n    this.reason = this.message\n\n    /* eslint-disable no-unused-expressions */\n    /**\n     * Whether this is a fatal problem that marks an associated file as no\n     * longer processable.\n     * If `true`, marks associated file as no longer processable.\n     * If `false`, necessitates a (potential) change.\n     * The value can also be `null` or `undefined`, for things that might not\n     * need changing.\n     *\n     * @type {boolean?}\n     */\n    this.fatal\n\n    /**\n     * Starting line of error.\n     *\n     * @type {number?}\n     */\n    this.line = position.start.line\n\n    /**\n     * Starting column of error.\n     *\n     * @type {number?}\n     */\n    this.column = position.start.column\n\n    /**\n     * Full range information, when available.\n     * Has `start` and `end` fields, both set to an object with `line` and\n     * `column`, set to `number?`.\n     *\n     * @type {Position?}\n     */\n    this.position = position\n\n    /**\n     * Namespace of warning (example: `'my-package'`).\n     *\n     * @type {string?}\n     */\n    this.source = parts[0]\n\n    /**\n     * Category of message (example: `'my-rule-name'`).\n     *\n     * @type {string?}\n     */\n    this.ruleId = parts[1]\n\n    /**\n     * Path of a file (used throughout the VFile ecosystem).\n     *\n     * @type {string?}\n     */\n    this.file\n\n    // The following fields are well known.\n    // Not standard.\n    // Feel free to add other non-standard fields to your messages.\n\n    /**\n     * Specify the source value thats being reported, which is deemed\n     * incorrect.\n     *\n     * @type {string?}\n     */\n    this.actual\n\n    /**\n     * Suggest values that should be used instead of `actual`, one or more\n     * values that are deemed as acceptable.\n     *\n     * @type {Array<string>?}\n     */\n    this.expected\n\n    /**\n     * Link to documentation for the message.\n     *\n     * @type {string?}\n     */\n    this.url\n\n    /**\n     * Long form description of the message (supported by `vfile-reporter`).\n     *\n     * @type {string?}\n     */\n    this.note\n    /* eslint-enable no-unused-expressions */\n  }\n}\n\nVFileMessage.prototype.file = ''\nVFileMessage.prototype.name = ''\nVFileMessage.prototype.reason = ''\nVFileMessage.prototype.message = ''\nVFileMessage.prototype.stack = ''\nVFileMessage.prototype.fatal = null\nVFileMessage.prototype.column = null\nVFileMessage.prototype.line = null\nVFileMessage.prototype.source = null\nVFileMessage.prototype.ruleId = null\nVFileMessage.prototype.position = null\n","// A derivative work based on:\n// <https://github.com/browserify/path-browserify>.\n// Which is licensed:\n//\n// MIT License\n//\n// Copyright (c) 2013 James Halliday\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of\n// this software and associated documentation files (the \"Software\"), to deal in\n// the Software without restriction, including without limitation the rights to\n// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n// the Software, and to permit persons to whom the Software is furnished to do so,\n// subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n// FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n// IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// A derivative work based on:\n//\n// Parts of that are extracted from Nodes internal `path` module:\n// <https://github.com/nodejs/node/blob/master/lib/path.js>.\n// Which is licensed:\n//\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nexport const path = {basename, dirname, extname, join, sep: '/'}\n\n/* eslint-disable max-depth, complexity */\n\n/**\n * @param {string} path\n * @param {string} [ext]\n * @returns {string}\n */\nfunction basename(path, ext) {\n  if (ext !== undefined && typeof ext !== 'string') {\n    throw new TypeError('\"ext\" argument must be a string')\n  }\n\n  assertPath(path)\n  let start = 0\n  let end = -1\n  let index = path.length\n  /** @type {boolean|undefined} */\n  let seenNonSlash\n\n  if (ext === undefined || ext.length === 0 || ext.length > path.length) {\n    while (index--) {\n      if (path.charCodeAt(index) === 47 /* `/` */) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now.\n        if (seenNonSlash) {\n          start = index + 1\n          break\n        }\n      } else if (end < 0) {\n        // We saw the first non-path separator, mark this as the end of our\n        // path component.\n        seenNonSlash = true\n        end = index + 1\n      }\n    }\n\n    return end < 0 ? '' : path.slice(start, end)\n  }\n\n  if (ext === path) {\n    return ''\n  }\n\n  let firstNonSlashEnd = -1\n  let extIndex = ext.length - 1\n\n  while (index--) {\n    if (path.charCodeAt(index) === 47 /* `/` */) {\n      // If we reached a path separator that was not part of a set of path\n      // separators at the end of the string, stop now.\n      if (seenNonSlash) {\n        start = index + 1\n        break\n      }\n    } else {\n      if (firstNonSlashEnd < 0) {\n        // We saw the first non-path separator, remember this index in case\n        // we need it if the extension ends up not matching.\n        seenNonSlash = true\n        firstNonSlashEnd = index + 1\n      }\n\n      if (extIndex > -1) {\n        // Try to match the explicit extension.\n        if (path.charCodeAt(index) === ext.charCodeAt(extIndex--)) {\n          if (extIndex < 0) {\n            // We matched the extension, so mark this as the end of our path\n            // component\n            end = index\n          }\n        } else {\n          // Extension does not match, so our result is the entire path\n          // component\n          extIndex = -1\n          end = firstNonSlashEnd\n        }\n      }\n    }\n  }\n\n  if (start === end) {\n    end = firstNonSlashEnd\n  } else if (end < 0) {\n    end = path.length\n  }\n\n  return path.slice(start, end)\n}\n\n/**\n * @param {string} path\n * @returns {string}\n */\nfunction dirname(path) {\n  assertPath(path)\n\n  if (path.length === 0) {\n    return '.'\n  }\n\n  let end = -1\n  let index = path.length\n  /** @type {boolean|undefined} */\n  let unmatchedSlash\n\n  // Prefix `--` is important to not run on `0`.\n  while (--index) {\n    if (path.charCodeAt(index) === 47 /* `/` */) {\n      if (unmatchedSlash) {\n        end = index\n        break\n      }\n    } else if (!unmatchedSlash) {\n      // We saw the first non-path separator\n      unmatchedSlash = true\n    }\n  }\n\n  return end < 0\n    ? path.charCodeAt(0) === 47 /* `/` */\n      ? '/'\n      : '.'\n    : end === 1 && path.charCodeAt(0) === 47 /* `/` */\n    ? '//'\n    : path.slice(0, end)\n}\n\n/**\n * @param {string} path\n * @returns {string}\n */\nfunction extname(path) {\n  assertPath(path)\n\n  let index = path.length\n\n  let end = -1\n  let startPart = 0\n  let startDot = -1\n  // Track the state of characters (if any) we see before our first dot and\n  // after any path separator we find.\n  let preDotState = 0\n  /** @type {boolean|undefined} */\n  let unmatchedSlash\n\n  while (index--) {\n    const code = path.charCodeAt(index)\n\n    if (code === 47 /* `/` */) {\n      // If we reached a path separator that was not part of a set of path\n      // separators at the end of the string, stop now.\n      if (unmatchedSlash) {\n        startPart = index + 1\n        break\n      }\n\n      continue\n    }\n\n    if (end < 0) {\n      // We saw the first non-path separator, mark this as the end of our\n      // extension.\n      unmatchedSlash = true\n      end = index + 1\n    }\n\n    if (code === 46 /* `.` */) {\n      // If this is our first dot, mark it as the start of our extension.\n      if (startDot < 0) {\n        startDot = index\n      } else if (preDotState !== 1) {\n        preDotState = 1\n      }\n    } else if (startDot > -1) {\n      // We saw a non-dot and non-path separator before our dot, so we should\n      // have a good chance at having a non-empty extension.\n      preDotState = -1\n    }\n  }\n\n  if (\n    startDot < 0 ||\n    end < 0 ||\n    // We saw a non-dot character immediately before the dot.\n    preDotState === 0 ||\n    // The (right-most) trimmed path component is exactly `..`.\n    (preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)\n  ) {\n    return ''\n  }\n\n  return path.slice(startDot, end)\n}\n\n/**\n * @param {Array<string>} segments\n * @returns {string}\n */\nfunction join(...segments) {\n  let index = -1\n  /** @type {string|undefined} */\n  let joined\n\n  while (++index < segments.length) {\n    assertPath(segments[index])\n\n    if (segments[index]) {\n      joined =\n        joined === undefined ? segments[index] : joined + '/' + segments[index]\n    }\n  }\n\n  return joined === undefined ? '.' : normalize(joined)\n}\n\n/**\n * Note: `normalize` is not exposed as `path.normalize`, so some code is\n * manually removed from it.\n *\n * @param {string} path\n * @returns {string}\n */\nfunction normalize(path) {\n  assertPath(path)\n\n  const absolute = path.charCodeAt(0) === 47 /* `/` */\n\n  // Normalize the path according to POSIX rules.\n  let value = normalizeString(path, !absolute)\n\n  if (value.length === 0 && !absolute) {\n    value = '.'\n  }\n\n  if (value.length > 0 && path.charCodeAt(path.length - 1) === 47 /* / */) {\n    value += '/'\n  }\n\n  return absolute ? '/' + value : value\n}\n\n/**\n * Resolve `.` and `..` elements in a path with directory names.\n *\n * @param {string} path\n * @param {boolean} allowAboveRoot\n * @returns {string}\n */\nfunction normalizeString(path, allowAboveRoot) {\n  let result = ''\n  let lastSegmentLength = 0\n  let lastSlash = -1\n  let dots = 0\n  let index = -1\n  /** @type {number|undefined} */\n  let code\n  /** @type {number} */\n  let lastSlashIndex\n\n  while (++index <= path.length) {\n    if (index < path.length) {\n      code = path.charCodeAt(index)\n    } else if (code === 47 /* `/` */) {\n      break\n    } else {\n      code = 47 /* `/` */\n    }\n\n    if (code === 47 /* `/` */) {\n      if (lastSlash === index - 1 || dots === 1) {\n        // Empty.\n      } else if (lastSlash !== index - 1 && dots === 2) {\n        if (\n          result.length < 2 ||\n          lastSegmentLength !== 2 ||\n          result.charCodeAt(result.length - 1) !== 46 /* `.` */ ||\n          result.charCodeAt(result.length - 2) !== 46 /* `.` */\n        ) {\n          if (result.length > 2) {\n            lastSlashIndex = result.lastIndexOf('/')\n\n            if (lastSlashIndex !== result.length - 1) {\n              if (lastSlashIndex < 0) {\n                result = ''\n                lastSegmentLength = 0\n              } else {\n                result = result.slice(0, lastSlashIndex)\n                lastSegmentLength = result.length - 1 - result.lastIndexOf('/')\n              }\n\n              lastSlash = index\n              dots = 0\n              continue\n            }\n          } else if (result.length > 0) {\n            result = ''\n            lastSegmentLength = 0\n            lastSlash = index\n            dots = 0\n            continue\n          }\n        }\n\n        if (allowAboveRoot) {\n          result = result.length > 0 ? result + '/..' : '..'\n          lastSegmentLength = 2\n        }\n      } else {\n        if (result.length > 0) {\n          result += '/' + path.slice(lastSlash + 1, index)\n        } else {\n          result = path.slice(lastSlash + 1, index)\n        }\n\n        lastSegmentLength = index - lastSlash - 1\n      }\n\n      lastSlash = index\n      dots = 0\n    } else if (code === 46 /* `.` */ && dots > -1) {\n      dots++\n    } else {\n      dots = -1\n    }\n  }\n\n  return result\n}\n\n/**\n * @param {string} path\n */\nfunction assertPath(path) {\n  if (typeof path !== 'string') {\n    throw new TypeError(\n      'Path must be a string. Received ' + JSON.stringify(path)\n    )\n  }\n}\n\n/* eslint-enable max-depth, complexity */\n","// Somewhat based on:\n// <https://github.com/defunctzombie/node-process/blob/master/browser.js>.\n// But I dont think one tiny line of code can be copyrighted. \nexport const proc = {cwd}\n\nfunction cwd() {\n  return '/'\n}\n","/**\n * @typedef URL\n * @property {string} hash\n * @property {string} host\n * @property {string} hostname\n * @property {string} href\n * @property {string} origin\n * @property {string} password\n * @property {string} pathname\n * @property {string} port\n * @property {string} protocol\n * @property {string} search\n * @property {any} searchParams\n * @property {string} username\n * @property {() => string} toString\n * @property {() => string} toJSON\n */\n\n/**\n * @param {unknown} fileURLOrPath\n * @returns {fileURLOrPath is URL}\n */\n// From: <https://github.com/nodejs/node/blob/fcf8ba4/lib/internal/url.js#L1501>\nexport function isUrl(fileURLOrPath) {\n  return (\n    fileURLOrPath !== null &&\n    typeof fileURLOrPath === 'object' &&\n    // @ts-expect-error: indexable.\n    fileURLOrPath.href &&\n    // @ts-expect-error: indexable.\n    fileURLOrPath.origin\n  )\n}\n","/// <reference lib=\"dom\" />\n\nimport {isUrl} from './minurl.shared.js'\n\n// See: <https://github.com/nodejs/node/blob/fcf8ba4/lib/internal/url.js>\n\n/**\n * @param {string|URL} path\n */\nexport function urlToPath(path) {\n  if (typeof path === 'string') {\n    path = new URL(path)\n  } else if (!isUrl(path)) {\n    /** @type {NodeJS.ErrnoException} */\n    const error = new TypeError(\n      'The \"path\" argument must be of type string or an instance of URL. Received `' +\n        path +\n        '`'\n    )\n    error.code = 'ERR_INVALID_ARG_TYPE'\n    throw error\n  }\n\n  if (path.protocol !== 'file:') {\n    /** @type {NodeJS.ErrnoException} */\n    const error = new TypeError('The URL must be of scheme file')\n    error.code = 'ERR_INVALID_URL_SCHEME'\n    throw error\n  }\n\n  return getPathFromURLPosix(path)\n}\n\n/**\n * @param {URL} url\n */\nfunction getPathFromURLPosix(url) {\n  if (url.hostname !== '') {\n    /** @type {NodeJS.ErrnoException} */\n    const error = new TypeError(\n      'File URL host must be \"localhost\" or empty on darwin'\n    )\n    error.code = 'ERR_INVALID_FILE_URL_HOST'\n    throw error\n  }\n\n  const pathname = url.pathname\n  let index = -1\n\n  while (++index < pathname.length) {\n    if (\n      pathname.charCodeAt(index) === 37 /* `%` */ &&\n      pathname.charCodeAt(index + 1) === 50 /* `2` */\n    ) {\n      const third = pathname.charCodeAt(index + 2)\n      if (third === 70 /* `F` */ || third === 102 /* `f` */) {\n        /** @type {NodeJS.ErrnoException} */\n        const error = new TypeError(\n          'File URL path must not include encoded / characters'\n        )\n        error.code = 'ERR_INVALID_FILE_URL_PATH'\n        throw error\n      }\n    }\n  }\n\n  return decodeURIComponent(pathname)\n}\n\nexport {isUrl} from './minurl.shared.js'\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Position} Position\n * @typedef {import('unist').Point} Point\n * @typedef {Record<string, unknown> & {type: string, position?: Position|undefined}} NodeLike\n * @typedef {import('./minurl.shared.js').URL} URL\n * @typedef {import('../index.js').Data} Data\n * @typedef {import('../index.js').Value} Value\n *\n * @typedef {'ascii'|'utf8'|'utf-8'|'utf16le'|'ucs2'|'ucs-2'|'base64'|'base64url'|'latin1'|'binary'|'hex'} BufferEncoding\n *   Encodings supported by the buffer class.\n *   This is a copy of the typing from Node, copied to prevent Node globals from\n *   being needed.\n *   Copied from: <https://github.com/DefinitelyTyped/DefinitelyTyped/blob/90a4ec8/types/node/buffer.d.ts#L170>\n *\n * @typedef {Value|Options|VFile|URL} Compatible\n *   Things that can be passed to the constructor.\n *\n * @typedef VFileCoreOptions\n * @property {Value} [value]\n * @property {string} [cwd]\n * @property {Array<string>} [history]\n * @property {string|URL} [path]\n * @property {string} [basename]\n * @property {string} [stem]\n * @property {string} [extname]\n * @property {string} [dirname]\n * @property {Data} [data]\n *\n * @typedef Map\n *   Raw source map, see:\n *   <https://github.com/mozilla/source-map/blob/58819f0/source-map.d.ts#L15-L23>.\n * @property {number} version\n * @property {Array<string>} sources\n * @property {Array<string>} names\n * @property {string|undefined} [sourceRoot]\n * @property {Array<string>|undefined} [sourcesContent]\n * @property {string} mappings\n * @property {string} file\n *\n * @typedef {{[key: string]: unknown} & VFileCoreOptions} Options\n *   Configuration: a bunch of keys that will be shallow copied over to the new\n *   file.\n *\n * @typedef {Record<string, unknown>} ReporterSettings\n * @typedef {<T = ReporterSettings>(files: Array<VFile>, options: T) => string} Reporter\n */\n\nimport buffer from 'is-buffer'\nimport {VFileMessage} from 'vfile-message'\nimport {path} from './minpath.js'\nimport {proc} from './minproc.js'\nimport {urlToPath, isUrl} from './minurl.js'\n\n// Order of setting (least specific to most), we need this because otherwise\n// `{stem: 'a', path: '~/b.js'}` would throw, as a path is needed before a\n// stem can be set.\nconst order = ['history', 'path', 'basename', 'stem', 'extname', 'dirname']\n\nexport class VFile {\n  /**\n   * Create a new virtual file.\n   *\n   * If `options` is `string` or `Buffer`, its treated as `{value: options}`.\n   * If `options` is a `URL`, its treated as `{path: options}`.\n   * If `options` is a `VFile`, shallow copies its data over to the new file.\n   * All fields in `options` are set on the newly created `VFile`.\n   *\n   * Path related fields are set in the following order (least specific to\n   * most specific): `history`, `path`, `basename`, `stem`, `extname`,\n   * `dirname`.\n   *\n   * Its not possible to set either `dirname` or `extname` without setting\n   * either `history`, `path`, `basename`, or `stem` as well.\n   *\n   * @param {Compatible} [value]\n   */\n  constructor(value) {\n    /** @type {Options} */\n    let options\n\n    if (!value) {\n      options = {}\n    } else if (typeof value === 'string' || buffer(value)) {\n      // @ts-expect-error Looks like a buffer.\n      options = {value}\n    } else if (isUrl(value)) {\n      options = {path: value}\n    } else {\n      // @ts-expect-error Looks like file or options.\n      options = value\n    }\n\n    /**\n     * Place to store custom information (default: `{}`).\n     * Its OK to store custom data directly on the file but moving it to\n     * `data` is recommended.\n     * @type {Data}\n     */\n    this.data = {}\n\n    /**\n     * List of messages associated with the file.\n     * @type {Array<VFileMessage>}\n     */\n    this.messages = []\n\n    /**\n     * List of filepaths the file moved between.\n     * The first is the original path and the last is the current path.\n     * @type {Array<string>}\n     */\n    this.history = []\n\n    /**\n     * Base of `path` (default: `process.cwd()` or `'/'` in browsers).\n     * @type {string}\n     */\n    this.cwd = proc.cwd()\n\n    /* eslint-disable no-unused-expressions */\n    /**\n     * Raw value.\n     * @type {Value}\n     */\n    this.value\n\n    // The below are non-standard, they are well-known.\n    // As in, used in several tools.\n\n    /**\n     * Whether a file was saved to disk.\n     * This is used by vfile reporters.\n     * @type {boolean}\n     */\n    this.stored\n\n    /**\n     * Sometimes files have a non-string, compiled, representation.\n     * This can be stored in the `result` field.\n     * One example is when turning markdown into React nodes.\n     * This is used by unified to store non-string results.\n     * @type {unknown}\n     */\n    this.result\n\n    /**\n     * Sometimes files have a source map associated with them.\n     * This can be stored in the `map` field.\n     * This should be a `Map` type, which is equivalent to the `RawSourceMap`\n     * type from the `source-map` module.\n     * @type {Map|undefined}\n     */\n    this.map\n    /* eslint-enable no-unused-expressions */\n\n    // Set path related properties in the correct order.\n    let index = -1\n\n    while (++index < order.length) {\n      const prop = order[index]\n\n      // Note: we specifically use `in` instead of `hasOwnProperty` to accept\n      // `vfile`s too.\n      if (prop in options && options[prop] !== undefined) {\n        // @ts-expect-error: TS is confused by the different types for `history`.\n        this[prop] = prop === 'history' ? [...options[prop]] : options[prop]\n      }\n    }\n\n    /** @type {string} */\n    let prop\n\n    // Set non-path related properties.\n    for (prop in options) {\n      // @ts-expect-error: fine to set other things.\n      if (!order.includes(prop)) this[prop] = options[prop]\n    }\n  }\n\n  /**\n   * Get the full path (example: `'~/index.min.js'`).\n   * @returns {string}\n   */\n  get path() {\n    return this.history[this.history.length - 1]\n  }\n\n  /**\n   * Set the full path (example: `'~/index.min.js'`).\n   * Cannot be nullified.\n   * You can set a file URL (a `URL` object with a `file:` protocol) which will\n   * be turned into a path with `url.fileURLToPath`.\n   * @param {string|URL} path\n   */\n  set path(path) {\n    if (isUrl(path)) {\n      path = urlToPath(path)\n    }\n\n    assertNonEmpty(path, 'path')\n\n    if (this.path !== path) {\n      this.history.push(path)\n    }\n  }\n\n  /**\n   * Get the parent path (example: `'~'`).\n   */\n  get dirname() {\n    return typeof this.path === 'string' ? path.dirname(this.path) : undefined\n  }\n\n  /**\n   * Set the parent path (example: `'~'`).\n   * Cannot be set if theres no `path` yet.\n   */\n  set dirname(dirname) {\n    assertPath(this.basename, 'dirname')\n    this.path = path.join(dirname || '', this.basename)\n  }\n\n  /**\n   * Get the basename (including extname) (example: `'index.min.js'`).\n   */\n  get basename() {\n    return typeof this.path === 'string' ? path.basename(this.path) : undefined\n  }\n\n  /**\n   * Set basename (including extname) (`'index.min.js'`).\n   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\\'`\n   * on windows).\n   * Cannot be nullified (use `file.path = file.dirname` instead).\n   */\n  set basename(basename) {\n    assertNonEmpty(basename, 'basename')\n    assertPart(basename, 'basename')\n    this.path = path.join(this.dirname || '', basename)\n  }\n\n  /**\n   * Get the extname (including dot) (example: `'.js'`).\n   */\n  get extname() {\n    return typeof this.path === 'string' ? path.extname(this.path) : undefined\n  }\n\n  /**\n   * Set the extname (including dot) (example: `'.js'`).\n   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\\'`\n   * on windows).\n   * Cannot be set if theres no `path` yet.\n   */\n  set extname(extname) {\n    assertPart(extname, 'extname')\n    assertPath(this.dirname, 'extname')\n\n    if (extname) {\n      if (extname.charCodeAt(0) !== 46 /* `.` */) {\n        throw new Error('`extname` must start with `.`')\n      }\n\n      if (extname.includes('.', 1)) {\n        throw new Error('`extname` cannot contain multiple dots')\n      }\n    }\n\n    this.path = path.join(this.dirname, this.stem + (extname || ''))\n  }\n\n  /**\n   * Get the stem (basename w/o extname) (example: `'index.min'`).\n   */\n  get stem() {\n    return typeof this.path === 'string'\n      ? path.basename(this.path, this.extname)\n      : undefined\n  }\n\n  /**\n   * Set the stem (basename w/o extname) (example: `'index.min'`).\n   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\\'`\n   * on windows).\n   * Cannot be nullified (use `file.path = file.dirname` instead).\n   */\n  set stem(stem) {\n    assertNonEmpty(stem, 'stem')\n    assertPart(stem, 'stem')\n    this.path = path.join(this.dirname || '', stem + (this.extname || ''))\n  }\n\n  /**\n   * Serialize the file.\n   *\n   * @param {BufferEncoding} [encoding='utf8']\n   *   When `value` is a `Buffer`, `encoding` is a character encoding to\n   *   understand it as (default: `'utf8'`).\n   * @returns {string}\n   *   Serialized file.\n   */\n  toString(encoding) {\n    return (this.value || '').toString(encoding)\n  }\n\n  /**\n   * Constructs a new `VFileMessage`, where `fatal` is set to `false`, and\n   * associates it with the file by adding it to `vfile.messages` and setting\n   * `message.file` to the current filepath.\n   *\n   * @param {string|Error|VFileMessage} reason\n   *   Human readable reason for the message, uses the stack and message of the error if given.\n   * @param {Node|NodeLike|Position|Point} [place]\n   *   Place where the message occurred in the file.\n   * @param {string} [origin]\n   *   Computer readable reason for the message\n   * @returns {VFileMessage}\n   *   Message.\n   */\n  message(reason, place, origin) {\n    const message = new VFileMessage(reason, place, origin)\n\n    if (this.path) {\n      message.name = this.path + ':' + message.name\n      message.file = this.path\n    }\n\n    message.fatal = false\n\n    this.messages.push(message)\n\n    return message\n  }\n\n  /**\n   * Like `VFile#message()`, but associates an informational message where\n   * `fatal` is set to `null`.\n   *\n   * @param {string|Error|VFileMessage} reason\n   *   Human readable reason for the message, uses the stack and message of the error if given.\n   * @param {Node|NodeLike|Position|Point} [place]\n   *   Place where the message occurred in the file.\n   * @param {string} [origin]\n   *   Computer readable reason for the message\n   * @returns {VFileMessage}\n   *   Message.\n   */\n  info(reason, place, origin) {\n    const message = this.message(reason, place, origin)\n\n    message.fatal = null\n\n    return message\n  }\n\n  /**\n   * Like `VFile#message()`, but associates a fatal message where `fatal` is\n   * set to `true`, and then immediately throws it.\n   *\n   * >  **Note**: a fatal error means that a file is no longer processable.\n   *\n   * @param {string|Error|VFileMessage} reason\n   *   Human readable reason for the message, uses the stack and message of the error if given.\n   * @param {Node|NodeLike|Position|Point} [place]\n   *   Place where the message occurred in the file.\n   * @param {string} [origin]\n   *   Computer readable reason for the message\n   * @returns {never}\n   *   Message.\n   */\n  fail(reason, place, origin) {\n    const message = this.message(reason, place, origin)\n\n    message.fatal = true\n\n    throw message\n  }\n}\n\n/**\n * Assert that `part` is not a path (as in, does not contain `path.sep`).\n *\n * @param {string|undefined} part\n * @param {string} name\n * @returns {void}\n */\nfunction assertPart(part, name) {\n  if (part && part.includes(path.sep)) {\n    throw new Error(\n      '`' + name + '` cannot be a path: did not expect `' + path.sep + '`'\n    )\n  }\n}\n\n/**\n * Assert that `part` is not empty.\n *\n * @param {string|undefined} part\n * @param {string} name\n * @returns {asserts part is string}\n */\nfunction assertNonEmpty(part, name) {\n  if (!part) {\n    throw new Error('`' + name + '` cannot be empty')\n  }\n}\n\n/**\n * Assert `path` exists.\n *\n * @param {string|undefined} path\n * @param {string} name\n * @returns {asserts path is string}\n */\nfunction assertPath(path, name) {\n  if (!path) {\n    throw new Error('Setting `' + name + '` requires `path` to be set too')\n  }\n}\n","/**\n * Map of web namespaces.\n *\n * @type {Record<string, string>}\n */\nexport const webNamespaces = {\n  html: 'http://www.w3.org/1999/xhtml',\n  mathml: 'http://www.w3.org/1998/Math/MathML',\n  svg: 'http://www.w3.org/2000/svg',\n  xlink: 'http://www.w3.org/1999/xlink',\n  xml: 'http://www.w3.org/XML/1998/namespace',\n  xmlns: 'http://www.w3.org/2000/xmlns/'\n}\n","/**\n * @callback Handler\n *   Handle a value, with a certain ID field set to a certain value.\n *   The ID field is passed to `zwitch`, and its value is this functions\n *   place on the `handlers` record.\n * @param {...any} parameters\n *   Arbitrary parameters passed to the zwitch.\n *   The first will be an object with a certain ID field set to a certain value.\n * @returns {any}\n *   Anything!\n */\n\n/**\n * @callback UnknownHandler\n *   Handle values that do have a certain ID field, but its set to a value\n *   that is not listed in the `handlers` record.\n * @param {unknown} value\n *   An object with a certain ID field set to an unknown value.\n * @param {...any} rest\n *   Arbitrary parameters passed to the zwitch.\n * @returns {any}\n *   Anything!\n */\n\n/**\n * @callback InvalidHandler\n *   Handle values that do not have a certain ID field.\n * @param {unknown} value\n *   Any unknown value.\n * @param {...any} rest\n *   Arbitrary parameters passed to the zwitch.\n * @returns {void|null|undefined|never}\n *   This should crash or return nothing.\n */\n\n/**\n * @template {InvalidHandler} [Invalid=InvalidHandler]\n * @template {UnknownHandler} [Unknown=UnknownHandler]\n * @template {Record<string, Handler>} [Handlers=Record<string, Handler>]\n * @typedef Options\n *   Configuration (required).\n * @property {Invalid} [invalid]\n *   Handler to use for invalid values.\n * @property {Unknown} [unknown]\n *   Handler to use for unknown values.\n * @property {Handlers} [handlers]\n *   Handlers to use.\n */\n\nconst own = {}.hasOwnProperty\n\n/**\n * Handle values based on a field.\n *\n * @template {InvalidHandler} [Invalid=InvalidHandler]\n * @template {UnknownHandler} [Unknown=UnknownHandler]\n * @template {Record<string, Handler>} [Handlers=Record<string, Handler>]\n * @param {string} key\n *   Field to switch on.\n * @param {Options<Invalid, Unknown, Handlers>} [options]\n *   Configuration (required).\n * @returns {{unknown: Unknown, invalid: Invalid, handlers: Handlers, (...parameters: Parameters<Handlers[keyof Handlers]>): ReturnType<Handlers[keyof Handlers]>, (...parameters: Parameters<Unknown>): ReturnType<Unknown>}}\n */\nexport function zwitch(key, options) {\n  const settings = options || {}\n\n  /**\n   * Handle one value.\n   *\n   * Based on the bound `key`, a respective handler will be called.\n   * If `value` is not an object, or doesnt have a `key` property, the special\n   * invalid handler will be called.\n   * If `value` has an unknown `key`, the special unknown handler will be\n   * called.\n   *\n   * All arguments, and the context object, are passed through to the handler,\n   * and its result is returned.\n   *\n   * @this {unknown}\n   *   Any context object.\n   * @param {unknown} [value]\n   *   Any value.\n   * @param {...unknown} parameters\n   *   Arbitrary parameters passed to the zwitch.\n   * @property {Handler} invalid\n   *   Handle for values that do not have a certain ID field.\n   * @property {Handler} unknown\n   *   Handle values that do have a certain ID field, but its set to a value\n   *   that is not listed in the `handlers` record.\n   * @property {Handlers} handlers\n   *   Record of handlers.\n   * @returns {unknown}\n   *   Anything.\n   */\n  function one(value, ...parameters) {\n    /** @type {Handler|undefined} */\n    let fn = one.invalid\n    const handlers = one.handlers\n\n    if (value && own.call(value, key)) {\n      // @ts-expect-error Indexable.\n      const id = String(value[key])\n      // @ts-expect-error Indexable.\n      fn = own.call(handlers, id) ? handlers[id] : one.unknown\n    }\n\n    if (fn) {\n      return fn.call(this, value, ...parameters)\n    }\n  }\n\n  one.handlers = settings.handlers || {}\n  one.invalid = settings.invalid\n  one.unknown = settings.unknown\n\n  // @ts-expect-error: matches!\n  return one\n}\n"],"names":["module","exports","objA","objB","compare","compareContext","ret","call","keysA","Object","keys","keysB","length","bHasOwnProperty","prototype","hasOwnProperty","bind","idx","key","valueA","valueB","parse","require","style","iterator","declaration","output","property","value","declarations","hasIterator","i","len","target","arguments","source","input","String","trim","split","stringify","values","join","COMMENT","RULESET","DECLARATION","IMPORT","KEYFRAMES","line","column","position","character","characters","node","root","parent","type","props","children","return","prev","charat","next","peek","caret","slice","begin","end","substr","token","alloc","strlen","dealloc","delimit","delimiter","whitespace","escaping","index","count","commenter","from","identifier","compile","rule","rules","rulesets","pseudo","points","offset","atrule","previous","variable","scanning","ampersand","reference","indexof","replace","append","comment","ruleset","post","size","sizeof","j","k","x","y","abs","z","serialize","callback","element","Math","fromCharCode","assign","pattern","replacement","search","indexOf","charCodeAt","array","push","trimLines","match","exec","last","lines","trimLine","start","startIndex","endIndex","code","codePointAt","isPlainObject","getPrototypeOf","Symbol","toStringTag","wrap","middleware","called","parameters","result","fnExpectsCallback","done","apply","this","error","exception","Promise","then","Error","unified","base","frozen","transformers","fns","pipeline","run","middlewareIndex","pop","TypeError","fn","undefined","use","middelware","trough","attachers","namespace","freezeIndex","processor","data","assertUnfrozen","own","Parser","Compiler","freeze","attacher","options","transformer","Number","POSITIVE_INFINITY","settings","addPlugin","Array","isArray","addList","addPreset","add","plugin","plugins","entry","isPlainObj","extend","doc","file","vfile","assertParser","newable","assertCompiler","assertNode","executor","resolve","reject","tree","runSync","complete","assertDone","bail","process","isBuffer","processSync","destination","name","asyncName","Boolean","looksLikeAVFile","VFile","u","findAfter","test","is","convert","generated","ok","check","castFactory","typeFactory","anyFactory","all","propsFactory","tests","checks","pointStart","point","pointEnd","removePosition","force","visit","stringifyPosition","pos","visitParents","visitor","reverse","step","factory","parents","tagName","defineProperty","subresult","grandparents","toResult","concat","location","indices","lastIndex","toPoint","toOffset","isNaN","VFileMessage","reason","place","origin","parts","message","stack","fatal","ruleId","actual","expected","url","note","path","basename","ext","assertPath","seenNonSlash","firstNonSlashEnd","extIndex","dirname","unmatchedSlash","extname","startPart","startDot","preDotState","joined","segments","normalize","sep","absolute","allowAboveRoot","lastSlashIndex","lastSegmentLength","lastSlash","dots","lastIndexOf","normalizeString","JSON","proc","cwd","isUrl","fileURLOrPath","href","urlToPath","URL","protocol","hostname","pathname","third","decodeURIComponent","getPathFromURLPosix","order","buffer","messages","history","stored","map","prop","includes","assertNonEmpty","assertPart","stem","encoding","toString","part","webNamespaces","html","mathml","svg","xlink","xml","xmlns","zwitch","one","invalid","handlers","id","unknown"],"sourceRoot":""}