{"version":3,"file":"static/js/315.00f31e24.chunk.js","mappings":"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","sources":["../node_modules/inline-style-parser/index.js","../node_modules/hast-util-parse-selector/index.js","../node_modules/hastscript/lib/core.js","../node_modules/hastscript/lib/svg-case-sensitive-tag-names.js","../node_modules/hastscript/lib/svg.js","../node_modules/hastscript/lib/html.js","../node_modules/hast-util-from-parse5/lib/index.js","../node_modules/hast-to-hyperscript/index.js","../node_modules/hast-util-to-parse5/lib/index.js","../node_modules/html-void-elements/index.js","../node_modules/hast-util-raw/lib/index.js","../node_modules/hast-util-is-element/index.js","../node_modules/hast-util-to-text/index.js","../node_modules/hast-util-whitespace/index.js"],"sourcesContent":["// http://www.w3.org/TR/CSS21/grammar.html\n// https://github.com/visionmedia/css-parse/pull/49#issuecomment-30088027\nvar COMMENT_REGEX = /\\/\\*[^*]*\\*+([^/*][^*]*\\*+)*\\//g;\n\nvar NEWLINE_REGEX = /\\n/g;\nvar WHITESPACE_REGEX = /^\\s*/;\n\n// declaration\nvar PROPERTY_REGEX = /^(\\*?[-#/*\\\\\\w]+(\\[[0-9a-z_-]+\\])?)\\s*/;\nvar COLON_REGEX = /^:\\s*/;\nvar VALUE_REGEX = /^((?:'(?:\\\\'|.)*?'|\"(?:\\\\\"|.)*?\"|\\([^)]*?\\)|[^};])+)/;\nvar SEMICOLON_REGEX = /^[;\\s]*/;\n\n// https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String/Trim#Polyfill\nvar TRIM_REGEX = /^\\s+|\\s+$/g;\n\n// strings\nvar NEWLINE = '\\n';\nvar FORWARD_SLASH = '/';\nvar ASTERISK = '*';\nvar EMPTY_STRING = '';\n\n// types\nvar TYPE_COMMENT = 'comment';\nvar TYPE_DECLARATION = 'declaration';\n\n/**\n * @param {String} style\n * @param {Object} [options]\n * @return {Object[]}\n * @throws {TypeError}\n * @throws {Error}\n */\nmodule.exports = function(style, options) {\n  if (typeof style !== 'string') {\n    throw new TypeError('First argument must be a string');\n  }\n\n  if (!style) return [];\n\n  options = options || {};\n\n  /**\n   * Positional.\n   */\n  var lineno = 1;\n  var column = 1;\n\n  /**\n   * Update lineno and column based on `str`.\n   *\n   * @param {String} str\n   */\n  function updatePosition(str) {\n    var lines = str.match(NEWLINE_REGEX);\n    if (lines) lineno += lines.length;\n    var i = str.lastIndexOf(NEWLINE);\n    column = ~i ? str.length - i : column + str.length;\n  }\n\n  /**\n   * Mark position and patch `node.position`.\n   *\n   * @return {Function}\n   */\n  function position() {\n    var start = { line: lineno, column: column };\n    return function(node) {\n      node.position = new Position(start);\n      whitespace();\n      return node;\n    };\n  }\n\n  /**\n   * Store position information for a node.\n   *\n   * @constructor\n   * @property {Object} start\n   * @property {Object} end\n   * @property {undefined|String} source\n   */\n  function Position(start) {\n    this.start = start;\n    this.end = { line: lineno, column: column };\n    this.source = options.source;\n  }\n\n  /**\n   * Non-enumerable source string.\n   */\n  Position.prototype.content = style;\n\n  var errorsList = [];\n\n  /**\n   * Error `msg`.\n   *\n   * @param {String} msg\n   * @throws {Error}\n   */\n  function error(msg) {\n    var err = new Error(\n      options.source + ':' + lineno + ':' + column + ': ' + msg\n    );\n    err.reason = msg;\n    err.filename = options.source;\n    err.line = lineno;\n    err.column = column;\n    err.source = style;\n\n    if (options.silent) {\n      errorsList.push(err);\n    } else {\n      throw err;\n    }\n  }\n\n  /**\n   * Match `re` and return captures.\n   *\n   * @param {RegExp} re\n   * @return {undefined|Array}\n   */\n  function match(re) {\n    var m = re.exec(style);\n    if (!m) return;\n    var str = m[0];\n    updatePosition(str);\n    style = style.slice(str.length);\n    return m;\n  }\n\n  /**\n   * Parse whitespace.\n   */\n  function whitespace() {\n    match(WHITESPACE_REGEX);\n  }\n\n  /**\n   * Parse comments.\n   *\n   * @param {Object[]} [rules]\n   * @return {Object[]}\n   */\n  function comments(rules) {\n    var c;\n    rules = rules || [];\n    while ((c = comment())) {\n      if (c !== false) {\n        rules.push(c);\n      }\n    }\n    return rules;\n  }\n\n  /**\n   * Parse comment.\n   *\n   * @return {Object}\n   * @throws {Error}\n   */\n  function comment() {\n    var pos = position();\n    if (FORWARD_SLASH != style.charAt(0) || ASTERISK != style.charAt(1)) return;\n\n    var i = 2;\n    while (\n      EMPTY_STRING != style.charAt(i) &&\n      (ASTERISK != style.charAt(i) || FORWARD_SLASH != style.charAt(i + 1))\n    ) {\n      ++i;\n    }\n    i += 2;\n\n    if (EMPTY_STRING === style.charAt(i - 1)) {\n      return error('End of comment missing');\n    }\n\n    var str = style.slice(2, i - 2);\n    column += 2;\n    updatePosition(str);\n    style = style.slice(i);\n    column += 2;\n\n    return pos({\n      type: TYPE_COMMENT,\n      comment: str\n    });\n  }\n\n  /**\n   * Parse declaration.\n   *\n   * @return {Object}\n   * @throws {Error}\n   */\n  function declaration() {\n    var pos = position();\n\n    // prop\n    var prop = match(PROPERTY_REGEX);\n    if (!prop) return;\n    comment();\n\n    // :\n    if (!match(COLON_REGEX)) return error(\"property missing ':'\");\n\n    // val\n    var val = match(VALUE_REGEX);\n\n    var ret = pos({\n      type: TYPE_DECLARATION,\n      property: trim(prop[0].replace(COMMENT_REGEX, EMPTY_STRING)),\n      value: val\n        ? trim(val[0].replace(COMMENT_REGEX, EMPTY_STRING))\n        : EMPTY_STRING\n    });\n\n    // ;\n    match(SEMICOLON_REGEX);\n\n    return ret;\n  }\n\n  /**\n   * Parse declarations.\n   *\n   * @return {Object[]}\n   */\n  function declarations() {\n    var decls = [];\n\n    comments(decls);\n\n    // declarations\n    var decl;\n    while ((decl = declaration())) {\n      if (decl !== false) {\n        decls.push(decl);\n        comments(decls);\n      }\n    }\n\n    return decls;\n  }\n\n  whitespace();\n  return declarations();\n};\n\n/**\n * Trim `str`.\n *\n * @param {String} str\n * @return {String}\n */\nfunction trim(str) {\n  return str ? str.replace(TRIM_REGEX, EMPTY_STRING) : EMPTY_STRING;\n}\n","/**\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('hast').Element} Element\n */\n\nvar search = /[#.]/g\n\n/**\n * Create a hast element from a simple CSS selector.\n *\n * @param selector A simple CSS selector.\n *   Can contain a tag-name (`foo`), classes (`.bar`), and an ID (`#baz`).\n *   Multiple classes are allowed.\n *   Uses the last ID if multiple IDs are found.\n * @param [defaultTagName='div'] Tag name to use if `selector` does not specify one.\n */\nexport const parseSelector =\n  /**\n   * @type {(\n   *  <Selector extends string, DefaultTagName extends string = 'div'>(selector?: Selector, defaultTagName?: DefaultTagName) => Element & {tagName: import('./extract.js').ExtractTagName<Selector, DefaultTagName>}\n   * )}\n   */\n  (\n    /**\n     * @param {string} [selector]\n     * @param {string} [defaultTagName='div']\n     * @returns {Element}\n     */\n    function (selector, defaultTagName = 'div') {\n      var value = selector || ''\n      /** @type {Properties} */\n      var props = {}\n      var start = 0\n      /** @type {string} */\n      var subvalue\n      /** @type {string} */\n      var previous\n      /** @type {RegExpMatchArray} */\n      var match\n\n      while (start < value.length) {\n        search.lastIndex = start\n        match = search.exec(value)\n        subvalue = value.slice(start, match ? match.index : value.length)\n\n        if (subvalue) {\n          if (!previous) {\n            defaultTagName = subvalue\n          } else if (previous === '#') {\n            props.id = subvalue\n          } else if (Array.isArray(props.className)) {\n            props.className.push(subvalue)\n          } else {\n            props.className = [subvalue]\n          }\n\n          start += subvalue.length\n        }\n\n        if (match) {\n          previous = match[0]\n          start++\n        }\n      }\n\n      return {\n        type: 'element',\n        tagName: defaultTagName,\n        properties: props,\n        children: []\n      }\n    }\n  )\n","/**\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Properties} Properties\n * @typedef {Root['children'][number]} Child\n * @typedef {Child|Root} Node\n * @typedef {import('property-information').Info} Info\n * @typedef {import('property-information').Schema} Schema\n *\n * @typedef {Root|Element} HResult\n * @typedef {string|number} HStyleValue\n * @typedef {Record<string, HStyleValue>} HStyle\n * @typedef {string|number|boolean|null|undefined} HPrimitiveValue\n * @typedef {Array<string|number>} HArrayValue\n * @typedef {HPrimitiveValue|HArrayValue} HPropertyValue\n * @typedef {{[property: string]: HPropertyValue|HStyle}} HProperties\n *   Acceptable properties value.\n *\n * @typedef {string|number|null|undefined} HPrimitiveChild\n * @typedef {Array<Node|HPrimitiveChild>} HArrayChild\n * @typedef {Node|HPrimitiveChild|HArrayChild} HChild\n *   Acceptable child value\n */\n\nimport {find, normalize} from 'property-information'\nimport {parseSelector} from 'hast-util-parse-selector'\nimport {parse as spaces} from 'space-separated-tokens'\nimport {parse as commas} from 'comma-separated-tokens'\n\nconst buttonTypes = new Set(['menu', 'submit', 'reset', 'button'])\n\nconst own = {}.hasOwnProperty\n\n/**\n * @param {Schema} schema\n * @param {string} defaultTagName\n * @param {Array<string>} [caseSensitive]\n */\nexport function core(schema, defaultTagName, caseSensitive) {\n  const adjust = caseSensitive && createAdjustMap(caseSensitive)\n\n  const h =\n    /**\n     * @type {{\n     *   (): Root\n     *   (selector: null|undefined, ...children: Array<HChild>): Root\n     *   (selector: string, properties?: HProperties, ...children: Array<HChild>): Element\n     *   (selector: string, ...children: Array<HChild>): Element\n     * }}\n     */\n    (\n      /**\n       * Hyperscript compatible DSL for creating virtual hast trees.\n       *\n       * @param {string|null} [selector]\n       * @param {HProperties|HChild} [properties]\n       * @param {Array<HChild>} children\n       * @returns {HResult}\n       */\n      function (selector, properties, ...children) {\n        let index = -1\n        /** @type {HResult} */\n        let node\n\n        if (selector === undefined || selector === null) {\n          node = {type: 'root', children: []}\n          // @ts-expect-error Properties are not supported for roots.\n          children.unshift(properties)\n        } else {\n          node = parseSelector(selector, defaultTagName)\n          // Normalize the name.\n          node.tagName = node.tagName.toLowerCase()\n          if (adjust && own.call(adjust, node.tagName)) {\n            node.tagName = adjust[node.tagName]\n          }\n\n          // Handle props.\n          if (isProperties(properties, node.tagName)) {\n            /** @type {string} */\n            let key\n\n            for (key in properties) {\n              if (own.call(properties, key)) {\n                // @ts-expect-error `node.properties` is set.\n                addProperty(schema, node.properties, key, properties[key])\n              }\n            }\n          } else {\n            children.unshift(properties)\n          }\n        }\n\n        // Handle children.\n        while (++index < children.length) {\n          addChild(node.children, children[index])\n        }\n\n        if (node.type === 'element' && node.tagName === 'template') {\n          node.content = {type: 'root', children: node.children}\n          node.children = []\n        }\n\n        return node\n      }\n    )\n\n  return h\n}\n\n/**\n * @param {HProperties|HChild} value\n * @param {string} name\n * @returns {value is HProperties}\n */\nfunction isProperties(value, name) {\n  if (\n    value === null ||\n    value === undefined ||\n    typeof value !== 'object' ||\n    Array.isArray(value)\n  ) {\n    return false\n  }\n\n  if (name === 'input' || !value.type || typeof value.type !== 'string') {\n    return true\n  }\n\n  if ('children' in value && Array.isArray(value.children)) {\n    return false\n  }\n\n  if (name === 'button') {\n    return buttonTypes.has(value.type.toLowerCase())\n  }\n\n  return !('value' in value)\n}\n\n/**\n * @param {Schema} schema\n * @param {Properties} properties\n * @param {string} key\n * @param {HStyle|HPropertyValue} value\n * @returns {void}\n */\nfunction addProperty(schema, properties, key, value) {\n  const info = find(schema, key)\n  let index = -1\n  /** @type {HPropertyValue} */\n  let result\n\n  // Ignore nullish and NaN values.\n  if (value === undefined || value === null) return\n\n  if (typeof value === 'number') {\n    // Ignore NaN.\n    if (Number.isNaN(value)) return\n\n    result = value\n  }\n  // Booleans.\n  else if (typeof value === 'boolean') {\n    result = value\n  }\n  // Handle list values.\n  else if (typeof value === 'string') {\n    if (info.spaceSeparated) {\n      result = spaces(value)\n    } else if (info.commaSeparated) {\n      result = commas(value)\n    } else if (info.commaOrSpaceSeparated) {\n      result = spaces(commas(value).join(' '))\n    } else {\n      result = parsePrimitive(info, info.property, value)\n    }\n  } else if (Array.isArray(value)) {\n    result = value.concat()\n  } else {\n    result = info.property === 'style' ? style(value) : String(value)\n  }\n\n  if (Array.isArray(result)) {\n    /** @type {Array<string|number>} */\n    const finalResult = []\n\n    while (++index < result.length) {\n      // @ts-expect-error Assume no booleans in array.\n      finalResult[index] = parsePrimitive(info, info.property, result[index])\n    }\n\n    result = finalResult\n  }\n\n  // Class names (which can be added both on the `selector` and here).\n  if (info.property === 'className' && Array.isArray(properties.className)) {\n    // @ts-expect-error Assume no booleans in `className`.\n    result = properties.className.concat(result)\n  }\n\n  properties[info.property] = result\n}\n\n/**\n * @param {Array<Child>} nodes\n * @param {HChild} value\n * @returns {void}\n */\nfunction addChild(nodes, value) {\n  let index = -1\n\n  if (value === undefined || value === null) {\n    // Empty.\n  } else if (typeof value === 'string' || typeof value === 'number') {\n    nodes.push({type: 'text', value: String(value)})\n  } else if (Array.isArray(value)) {\n    while (++index < value.length) {\n      addChild(nodes, value[index])\n    }\n  } else if (typeof value === 'object' && 'type' in value) {\n    if (value.type === 'root') {\n      addChild(nodes, value.children)\n    } else {\n      nodes.push(value)\n    }\n  } else {\n    throw new Error('Expected node, nodes, or string, got `' + value + '`')\n  }\n}\n\n/**\n * Parse a single primitives.\n *\n * @param {Info} info\n * @param {string} name\n * @param {HPrimitiveValue} value\n * @returns {HPrimitiveValue}\n */\nfunction parsePrimitive(info, name, value) {\n  if (typeof value === 'string') {\n    if (info.number && value && !Number.isNaN(Number(value))) {\n      return Number(value)\n    }\n\n    if (\n      (info.boolean || info.overloadedBoolean) &&\n      (value === '' || normalize(value) === normalize(name))\n    ) {\n      return true\n    }\n  }\n\n  return value\n}\n\n/**\n * @param {HStyle} value\n * @returns {string}\n */\nfunction style(value) {\n  /** @type {Array<string>} */\n  const result = []\n  /** @type {string} */\n  let key\n\n  for (key in value) {\n    if (own.call(value, key)) {\n      result.push([key, value[key]].join(': '))\n    }\n  }\n\n  return result.join('; ')\n}\n\n/**\n * @param {Array<string>} values\n * @returns {Record<string, string>}\n */\nfunction createAdjustMap(values) {\n  /** @type {Record<string, string>} */\n  const result = {}\n  let index = -1\n\n  while (++index < values.length) {\n    result[values[index].toLowerCase()] = values[index]\n  }\n\n  return result\n}\n","export const svgCaseSensitiveTagNames = [\n  'altGlyph',\n  'altGlyphDef',\n  'altGlyphItem',\n  'animateColor',\n  'animateMotion',\n  'animateTransform',\n  'clipPath',\n  'feBlend',\n  'feColorMatrix',\n  'feComponentTransfer',\n  'feComposite',\n  'feConvolveMatrix',\n  'feDiffuseLighting',\n  'feDisplacementMap',\n  'feDistantLight',\n  'feDropShadow',\n  'feFlood',\n  'feFuncA',\n  'feFuncB',\n  'feFuncG',\n  'feFuncR',\n  'feGaussianBlur',\n  'feImage',\n  'feMerge',\n  'feMergeNode',\n  'feMorphology',\n  'feOffset',\n  'fePointLight',\n  'feSpecularLighting',\n  'feSpotLight',\n  'feTile',\n  'feTurbulence',\n  'foreignObject',\n  'glyphRef',\n  'linearGradient',\n  'radialGradient',\n  'solidColor',\n  'textArea',\n  'textPath'\n]\n","/**\n * @typedef {import('./core.js').HChild} Child\n * @typedef {import('./core.js').HProperties} Properties\n *\n * @typedef {import('./jsx-classic').Element} s.JSX.Element\n * @typedef {import('./jsx-classic').IntrinsicAttributes} s.JSX.IntrinsicAttributes\n * @typedef {import('./jsx-classic').IntrinsicElements} s.JSX.IntrinsicElements\n * @typedef {import('./jsx-classic').ElementChildrenAttribute} s.JSX.ElementChildrenAttribute\n */\n\nimport {svg} from 'property-information'\nimport {core} from './core.js'\nimport {svgCaseSensitiveTagNames} from './svg-case-sensitive-tag-names.js'\n\nexport const s = core(svg, 'g', svgCaseSensitiveTagNames)\n","/**\n * @typedef {import('./core.js').HChild} Child Acceptable child value\n * @typedef {import('./core.js').HProperties} Properties Acceptable properties value.\n *\n * @typedef {import('./jsx-classic').Element} h.JSX.Element\n * @typedef {import('./jsx-classic').IntrinsicAttributes} h.JSX.IntrinsicAttributes\n * @typedef {import('./jsx-classic').IntrinsicElements} h.JSX.IntrinsicElements\n * @typedef {import('./jsx-classic').ElementChildrenAttribute} h.JSX.ElementChildrenAttribute\n */\n\nimport {html} from 'property-information'\nimport {core} from './core.js'\n\nexport const h = core(html, 'div')\n","/**\n * @typedef {import('vfile').VFile} VFile\n * @typedef {import('property-information').Schema} Schema\n * @typedef {import('unist').Position} Position\n * @typedef {import('unist').Point} Point\n * @typedef {import('hast').Parent} Parent\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').Text} Text\n * @typedef {import('hast').Comment} Comment\n * @typedef {import('hast').DocType} Doctype\n * @typedef {Parent['children'][number]} Child\n * @typedef {Element['children'][number]} ElementChild\n * @typedef {Child|Root} Node\n * @typedef {import('parse5').Document} P5Document\n * @typedef {import('parse5').DocumentType} P5Doctype\n * @typedef {import('parse5').CommentNode} P5Comment\n * @typedef {import('parse5').TextNode} P5Text\n * @typedef {import('parse5').Element} P5Element\n * @typedef {import('parse5').ElementLocation} P5ElementLocation\n * @typedef {import('parse5').Location} P5Location\n * @typedef {import('parse5').Attribute} P5Attribute\n * @typedef {import('parse5').Node} P5Node\n *\n * @typedef {'html'|'svg'} Space\n *\n * @callback Handler\n * @param {Context} ctx\n * @param {P5Node} node\n * @param {Array.<Child>} [children]\n * @returns {Node}\n *\n * @typedef Options\n * @property {Space} [space='html'] Whether the root of the tree is in the `'html'` or `'svg'` space. If an element in with the SVG namespace is found in `ast`, `fromParse5` automatically switches to the SVG space when entering the element, and switches back when leaving\n * @property {VFile} [file] `VFile`, used to add positional information to nodes. If given, the file should have the original HTML source as its contents\n * @property {boolean} [verbose=false] Whether to add extra positional information about starting tags, closing tags, and attributes to elements. Note: not used without `file`\n *\n * @typedef Context\n * @property {Schema} schema\n * @property {VFile|undefined} file\n * @property {boolean|undefined} verbose\n * @property {boolean} location\n */\n\nimport {h, s} from 'hastscript'\nimport {html, svg, find} from 'property-information'\nimport {location} from 'vfile-location'\nimport {webNamespaces} from 'web-namespaces'\n\nconst own = {}.hasOwnProperty\n\n// Handlers.\nconst map = {\n  '#document': root,\n  '#document-fragment': root,\n  '#text': text,\n  '#comment': comment,\n  '#documentType': doctype\n}\n\n/**\n * Transform Parse5’s AST to a hast tree.\n *\n * @param {P5Node} ast\n * @param {Options|VFile} [options]\n */\nexport function fromParse5(ast, options = {}) {\n  /** @type {Options} */\n  let settings\n  /** @type {VFile|undefined} */\n  let file\n\n  if (isFile(options)) {\n    file = options\n    settings = {}\n  } else {\n    file = options.file\n    settings = options\n  }\n\n  return transform(\n    {\n      schema: settings.space === 'svg' ? svg : html,\n      file,\n      verbose: settings.verbose,\n      location: false\n    },\n    ast\n  )\n}\n\n/**\n * Transform children.\n *\n * @param {Context} ctx\n * @param {P5Node} ast\n * @returns {Node}\n */\nfunction transform(ctx, ast) {\n  const schema = ctx.schema\n  /** @type {Handler} */\n  // @ts-expect-error: index is fine.\n  const fn = own.call(map, ast.nodeName) ? map[ast.nodeName] : element\n  /** @type {Array.<Child>|undefined} */\n  let children\n\n  // Element.\n  if ('tagName' in ast) {\n    ctx.schema = ast.namespaceURI === webNamespaces.svg ? svg : html\n  }\n\n  if ('childNodes' in ast) {\n    children = nodes(ctx, ast.childNodes)\n  }\n\n  const result = fn(ctx, ast, children)\n\n  if ('sourceCodeLocation' in ast && ast.sourceCodeLocation && ctx.file) {\n    // @ts-expect-error It’s fine.\n    const position = createLocation(ctx, result, ast.sourceCodeLocation)\n\n    if (position) {\n      ctx.location = true\n      result.position = position\n    }\n  }\n\n  ctx.schema = schema\n\n  return result\n}\n\n/**\n * Transform children.\n *\n * @param {Context} ctx\n * @param {Array.<P5Node>} children\n * @returns {Array.<Child>}\n */\nfunction nodes(ctx, children) {\n  let index = -1\n  /** @type {Array.<Child>} */\n  const result = []\n\n  while (++index < children.length) {\n    // @ts-expect-error Assume no roots in children.\n    result[index] = transform(ctx, children[index])\n  }\n\n  return result\n}\n\n/**\n * Transform a document.\n * Stores `ast.quirksMode` in `node.data.quirksMode`.\n *\n * @type {Handler}\n * @param {P5Document} ast\n * @param {Array.<Child>} children\n * @returns {Root}\n */\nfunction root(ctx, ast, children) {\n  /** @type {Root} */\n  const result = {\n    type: 'root',\n    children,\n    data: {quirksMode: ast.mode === 'quirks' || ast.mode === 'limited-quirks'}\n  }\n\n  if (ctx.file && ctx.location) {\n    const doc = String(ctx.file)\n    const loc = location(doc)\n    result.position = {\n      start: loc.toPoint(0),\n      end: loc.toPoint(doc.length)\n    }\n  }\n\n  return result\n}\n\n/**\n * Transform a doctype.\n *\n * @type {Handler}\n * @returns {Doctype}\n */\nfunction doctype() {\n  // @ts-expect-error Types are out of date.\n  return {type: 'doctype'}\n}\n\n/**\n * Transform a text.\n *\n * @type {Handler}\n * @param {P5Text} ast\n * @returns {Text}\n */\nfunction text(_, ast) {\n  return {type: 'text', value: ast.value}\n}\n\n/**\n * Transform a comment.\n *\n * @type {Handler}\n * @param {P5Comment} ast\n * @returns {Comment}\n */\nfunction comment(_, ast) {\n  return {type: 'comment', value: ast.data}\n}\n\n/**\n * Transform an element.\n *\n * @type {Handler}\n * @param {P5Element} ast\n * @param {Array.<ElementChild>} children\n * @returns {Element}\n */\nfunction element(ctx, ast, children) {\n  const fn = ctx.schema.space === 'svg' ? s : h\n  let index = -1\n  /** @type {Object.<string, string>} */\n  const props = {}\n\n  while (++index < ast.attrs.length) {\n    const attribute = ast.attrs[index]\n    props[(attribute.prefix ? attribute.prefix + ':' : '') + attribute.name] =\n      attribute.value\n  }\n\n  const result = fn(ast.tagName, props, children)\n\n  if (result.tagName === 'template' && 'content' in ast) {\n    const pos = ast.sourceCodeLocation\n    const startTag = pos && pos.startTag && position(pos.startTag)\n    const endTag = pos && pos.endTag && position(pos.endTag)\n\n    /** @type {Root} */\n    // @ts-expect-error Types are wrong.\n    const content = transform(ctx, ast.content)\n\n    if (startTag && endTag && ctx.file) {\n      content.position = {start: startTag.end, end: endTag.start}\n    }\n\n    result.content = content\n  }\n\n  return result\n}\n\n/**\n * Create clean positional information.\n *\n * @param {Context} ctx\n * @param {Node} node\n * @param {P5ElementLocation} location\n * @returns {Position|null}\n */\nfunction createLocation(ctx, node, location) {\n  const result = position(location)\n\n  if (node.type === 'element') {\n    const tail = node.children[node.children.length - 1]\n\n    // Bug for unclosed with children.\n    // See: <https://github.com/inikulin/parse5/issues/109>.\n    if (\n      result &&\n      !location.endTag &&\n      tail &&\n      tail.position &&\n      tail.position.end\n    ) {\n      result.end = Object.assign({}, tail.position.end)\n    }\n\n    if (ctx.verbose) {\n      /** @type {Object.<string, Position|null>} */\n      const props = {}\n      /** @type {string} */\n      let key\n\n      for (key in location.attrs) {\n        if (own.call(location.attrs, key)) {\n          props[find(ctx.schema, key).property] = position(location.attrs[key])\n        }\n      }\n\n      node.data = {\n        position: {\n          opening: position(location.startTag),\n          closing: location.endTag ? position(location.endTag) : null,\n          properties: props\n        }\n      }\n    }\n  }\n\n  return result\n}\n\n/**\n * @param {P5Location} loc\n * @returns {Position|null}\n */\nfunction position(loc) {\n  const start = point({\n    line: loc.startLine,\n    column: loc.startCol,\n    offset: loc.startOffset\n  })\n  const end = point({\n    line: loc.endLine,\n    column: loc.endCol,\n    offset: loc.endOffset\n  })\n  // @ts-expect-error `null` is fine.\n  return start || end ? {start, end} : null\n}\n\n/**\n * @param {Point} point\n * @returns {Point|null}\n */\nfunction point(point) {\n  return point.line && point.column ? point : null\n}\n\n/**\n * @param {VFile|Options} value\n * @returns {value is VFile}\n */\nfunction isFile(value) {\n  return 'messages' in value\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').Text} Text\n *\n * @typedef {import('unist-util-is').AssertPredicate<Element>} AssertElement\n * @typedef {import('unist-util-is').AssertPredicate<Text>} AssertText\n * @typedef {import('unist-util-is').AssertPredicate<Root>} AssertRoot\n *\n * @callback CreateElementLike\n * @param {string} name\n * @param {any} attributes\n * @param {Array.<string|any>} [children]\n * @returns {any}\n *\n * @typedef Context\n * @property {html|svg} schema\n * @property {string|null} prefix\n * @property {number} key\n * @property {boolean} react\n * @property {boolean} vue\n * @property {boolean} vdom\n * @property {boolean} hyperscript\n *\n * @typedef Options\n * @property {string|null} [prefix]\n * @property {'html'|'svg'} [space]\n */\n\nimport {html, svg, find, hastToReact} from 'property-information'\nimport {stringify as spaces} from 'space-separated-tokens'\nimport {stringify as commas} from 'comma-separated-tokens'\nimport style from 'style-to-object'\nimport {webNamespaces} from 'web-namespaces'\nimport {convert} from 'unist-util-is'\n\nconst ns = /** @type {Record<string, string>} */ (webNamespaces)\nconst toReact = /** @type {Record<string, string>} */ (hastToReact)\n\nconst own = {}.hasOwnProperty\n\n/** @type {AssertRoot} */\n// @ts-expect-error it’s correct.\nconst root = convert('root')\n/** @type {AssertElement} */\n// @ts-expect-error it’s correct.\nconst element = convert('element')\n/** @type {AssertText} */\n// @ts-expect-error it’s correct.\nconst text = convert('text')\n\n/**\n * @template {CreateElementLike} H\n * @param {H} h\n * @param {Element|Root} tree\n * @param {string|boolean|Options} [options]\n * @returns {ReturnType<H>}\n */\nexport function toH(h, tree, options) {\n  if (typeof h !== 'function') {\n    throw new TypeError('h is not a function')\n  }\n\n  const r = react(h)\n  const v = vue(h)\n  const vd = vdom(h)\n  /** @type {string|boolean|null|undefined} */\n  let prefix\n  /** @type {Element} */\n  let node\n\n  if (typeof options === 'string' || typeof options === 'boolean') {\n    prefix = options\n    options = {}\n  } else {\n    if (!options) options = {}\n    prefix = options.prefix\n  }\n\n  if (root(tree)) {\n    // @ts-expect-error Allow `doctypes` in there, we’ll filter them out later.\n    node =\n      tree.children.length === 1 && element(tree.children[0])\n        ? tree.children[0]\n        : {\n            type: 'element',\n            tagName: 'div',\n            properties: {},\n            children: tree.children\n          }\n  } else if (element(tree)) {\n    node = tree\n  } else {\n    throw new Error(\n      // @ts-expect-error runtime.\n      'Expected root or element, not `' + ((tree && tree.type) || tree) + '`'\n    )\n  }\n\n  return transform(h, node, {\n    schema: options.space === 'svg' ? svg : html,\n    prefix:\n      prefix === undefined || prefix === null\n        ? r || v || vd\n          ? 'h-'\n          : null\n        : typeof prefix === 'string'\n        ? prefix\n        : prefix\n        ? 'h-'\n        : null,\n    key: 0,\n    react: r,\n    vue: v,\n    vdom: vd,\n    hyperscript: hyperscript(h)\n  })\n}\n\n/**\n * Transform a hast node through a hyperscript interface to *anything*!\n *\n * @template {CreateElementLike} H\n * @param {H} h\n * @param {Element} node\n * @param {Context} ctx\n */\nfunction transform(h, node, ctx) {\n  const parentSchema = ctx.schema\n  let schema = parentSchema\n  let name = node.tagName\n  /** @type {Record<string, unknown>} */\n  const attributes = {}\n  /** @type {Array.<ReturnType<H>|string>} */\n  const nodes = []\n  let index = -1\n  /** @type {string} */\n  let key\n\n  if (parentSchema.space === 'html' && name.toLowerCase() === 'svg') {\n    schema = svg\n    ctx.schema = schema\n  }\n\n  for (key in node.properties) {\n    if (node.properties && own.call(node.properties, key)) {\n      addAttribute(attributes, key, node.properties[key], ctx, name)\n    }\n  }\n\n  if (ctx.vdom) {\n    if (schema.space === 'html') {\n      name = name.toUpperCase()\n    } else if (schema.space) {\n      attributes.namespace = ns[schema.space]\n    }\n  }\n\n  if (ctx.prefix) {\n    ctx.key++\n    attributes.key = ctx.prefix + ctx.key\n  }\n\n  if (node.children) {\n    while (++index < node.children.length) {\n      const value = node.children[index]\n\n      if (element(value)) {\n        nodes.push(transform(h, value, ctx))\n      } else if (text(value)) {\n        nodes.push(value.value)\n      }\n    }\n  }\n\n  // Restore parent schema.\n  ctx.schema = parentSchema\n\n  // Ensure no React warnings are triggered for void elements having children\n  // passed in.\n  return nodes.length > 0\n    ? h.call(node, name, attributes, nodes)\n    : h.call(node, name, attributes)\n}\n\n/**\n * @param {Record<string, unknown>} props\n * @param {string} prop\n * @param {unknown} value\n * @param {Context} ctx\n * @param {string} name\n */\n// eslint-disable-next-line complexity, max-params\nfunction addAttribute(props, prop, value, ctx, name) {\n  const info = find(ctx.schema, prop)\n  /** @type {string|undefined} */\n  let subprop\n\n  // Ignore nullish and `NaN` values.\n  // Ignore `false` and falsey known booleans for hyperlike DSLs.\n  if (\n    value === undefined ||\n    value === null ||\n    (typeof value === 'number' && Number.isNaN(value)) ||\n    (value === false && (ctx.vue || ctx.vdom || ctx.hyperscript)) ||\n    (!value && info.boolean && (ctx.vue || ctx.vdom || ctx.hyperscript))\n  ) {\n    return\n  }\n\n  if (Array.isArray(value)) {\n    // Accept `array`.\n    // Most props are space-separated.\n    value = info.commaSeparated ? commas(value) : spaces(value)\n  }\n\n  // Treat `true` and truthy known booleans.\n  if (info.boolean && ctx.hyperscript) {\n    value = ''\n  }\n\n  // VDOM, Vue, and React accept `style` as object.\n  if (\n    info.property === 'style' &&\n    typeof value === 'string' &&\n    (ctx.react || ctx.vue || ctx.vdom)\n  ) {\n    value = parseStyle(value, name)\n  }\n\n  if (ctx.vue) {\n    if (info.property !== 'style') subprop = 'attrs'\n  } else if (!info.mustUseProperty) {\n    if (ctx.vdom) {\n      if (info.property !== 'style') subprop = 'attributes'\n    } else if (ctx.hyperscript) {\n      subprop = 'attrs'\n    }\n  }\n\n  if (subprop) {\n    props[subprop] = Object.assign(props[subprop] || {}, {\n      [info.attribute]: value\n    })\n  } else if (info.space && ctx.react) {\n    props[toReact[info.property] || info.property] = value\n  } else {\n    props[info.attribute] = value\n  }\n}\n\n/**\n * Check if `h` is `react.createElement`.\n *\n * @param {CreateElementLike} h\n * @returns {boolean}\n */\nfunction react(h) {\n  /** @type {unknown} */\n  const node = h('div', {})\n  return Boolean(\n    node &&\n      // @ts-expect-error Looks like a React node.\n      ('_owner' in node || '_store' in node) &&\n      // @ts-expect-error Looks like a React node.\n      (node.key === undefined || node.key === null)\n  )\n}\n\n/**\n * Check if `h` is `hyperscript`.\n *\n * @param {CreateElementLike} h\n * @returns {boolean}\n */\nfunction hyperscript(h) {\n  return 'context' in h && 'cleanup' in h\n}\n\n/**\n * Check if `h` is `virtual-dom/h`.\n *\n * @param {CreateElementLike} h\n * @returns {boolean}\n */\nfunction vdom(h) {\n  /** @type {unknown} */\n  const node = h('div', {})\n  // @ts-expect-error Looks like a vnode.\n  return node.type === 'VirtualNode'\n}\n\n/**\n * Check if `h` is Vue.\n *\n * @param {CreateElementLike} h\n * @returns {boolean}\n */\nfunction vue(h) {\n  /** @type {unknown} */\n  const node = h('div', {})\n  // @ts-expect-error Looks like a Vue node.\n  return Boolean(node && node.context && node.context._isVue)\n}\n\n/**\n * @param {string} value\n * @param {string} tagName\n * @returns {Record<string, string>}\n */\nfunction parseStyle(value, tagName) {\n  /** @type {Record<string, string>} */\n  const result = {}\n\n  try {\n    style(value, (name, value) => {\n      if (name.slice(0, 4) === '-ms-') name = 'ms-' + name.slice(4)\n\n      result[\n        name.replace(\n          /-([a-z])/g,\n          /**\n           * @param {string} _\n           * @param {string} $1\n           * @returns {string}\n           */ (_, $1) => $1.toUpperCase()\n        )\n      ] = value\n    })\n  } catch (error) {\n    error.message =\n      tagName + '[style]' + error.message.slice('undefined'.length)\n    throw error\n  }\n\n  return result\n}\n","/**\n * @typedef {import('parse5').Node} P5Node\n * @typedef {import('parse5').Document} P5Document\n * @typedef {import('parse5').DocumentFragment} P5Fragment\n * @typedef {import('parse5').DocumentType} P5Doctype\n * @typedef {import('parse5').CommentNode} P5Comment\n * @typedef {import('parse5').TextNode} P5Text\n * @typedef {import('parse5').Element} P5Element\n * @typedef {import('parse5').Attribute} P5Attribute\n * @typedef {import('parse5').ParentNode} P5Parent\n * @typedef {Exclude<P5Node, P5Document|P5Fragment>} P5Child\n * @typedef {import('property-information').Schema} Schema\n * @typedef {import('property-information').Info} Info\n * @typedef {'html'|'svg'} Space\n * @typedef {import('hast').Parent} Parent\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').DocType} Doctype\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Text} Text\n * @typedef {import('hast').Comment} Comment\n * @typedef {Parent['children'][number]} Child\n * @typedef {Child|Root} Node\n *\n * @callback Handle\n * @param {Node} node\n * @param {Schema} schema\n * @returns {P5Node}\n */\n\nimport {html, svg, find} from 'property-information'\nimport {toH} from 'hast-to-hyperscript'\nimport {webNamespaces} from 'web-namespaces'\nimport {zwitch} from 'zwitch'\n\nvar own = {}.hasOwnProperty\n\nvar one = zwitch('type', {handlers: {root, element, text, comment, doctype}})\n\n/**\n * Transform a tree from hast to Parse5’s AST.\n *\n * @param {Node} tree\n * @param {Space} [space='html']\n * @returns {P5Node}\n */\nexport function toParse5(tree, space) {\n  // @ts-ignore Types are wrong.\n  return one(tree, space === 'svg' ? svg : html)\n}\n\n/**\n * @type {Handle}\n * @param {Root} node\n * @returns {P5Document}\n */\nfunction root(node, schema) {\n  /** @type {P5Document} */\n  var p5 = {\n    nodeName: '#document',\n    mode: (node.data || {}).quirksMode ? 'quirks' : 'no-quirks',\n    childNodes: []\n  }\n  // @ts-ignore Assume correct children.\n  p5.childNodes = all(node.children, p5, schema)\n  return patch(node, p5)\n}\n\n/**\n * @type {Handle}\n * @param {Root} node\n * @returns {P5Fragment}\n */\nfunction fragment(node, schema) {\n  /** @type {P5Fragment} */\n  var p5 = {nodeName: '#document-fragment', childNodes: []}\n  // @ts-ignore Assume correct children.\n  p5.childNodes = all(node.children, p5, schema)\n  return patch(node, p5)\n}\n\n/**\n * @type {Handle}\n * @param {Doctype} node\n * @returns {P5Doctype}\n */\nfunction doctype(node) {\n  return patch(node, {\n    nodeName: '#documentType',\n    name: 'html',\n    publicId: '',\n    systemId: '',\n    parentNode: undefined\n  })\n}\n\n/**\n * @type {Handle}\n * @param {Text} node\n * @returns {P5Text}\n */\nfunction text(node) {\n  return patch(node, {\n    nodeName: '#text',\n    value: node.value,\n    parentNode: undefined\n  })\n}\n\n/**\n * @type {Handle}\n * @param {Comment} node\n * @returns {P5Comment}\n */\nfunction comment(node) {\n  return patch(node, {\n    nodeName: '#comment',\n    data: node.value,\n    parentNode: undefined\n  })\n}\n\n/**\n * @type {Handle}\n * @param {Element} node\n * @returns {P5Element}\n */\nfunction element(node, schema) {\n  /** @type {Space} */\n  // @ts-ignore Assume space.\n  var space = schema.space\n  return toH(h, Object.assign({}, node, {children: []}), {space})\n\n  /**\n   * @param {string} name\n   * @param {Object.<string, string|boolean|number>} attrs\n   */\n  function h(name, attrs) {\n    /** @type {Array.<P5Attribute>} */\n    var values = []\n    /** @type {Info} */\n    var info\n    /** @type {P5Attribute} */\n    var value\n    /** @type {string} */\n    var key\n    /** @type {number} */\n    var index\n    /** @type {P5Element} */\n    var p5\n\n    for (key in attrs) {\n      if (!own.call(attrs, key) || attrs[key] === false) {\n        continue\n      }\n\n      info = find(schema, key)\n\n      if (info.boolean && !attrs[key]) {\n        continue\n      }\n\n      value = {name: key, value: attrs[key] === true ? '' : String(attrs[key])}\n\n      if (info.space && info.space !== 'html' && info.space !== 'svg') {\n        index = key.indexOf(':')\n\n        if (index < 0) {\n          value.prefix = ''\n        } else {\n          value.name = key.slice(index + 1)\n          value.prefix = key.slice(0, index)\n        }\n\n        value.namespace = webNamespaces[info.space]\n      }\n\n      values.push(value)\n    }\n\n    if (schema.space === 'html' && node.tagName === 'svg') schema = svg\n\n    p5 = patch(node, {\n      nodeName: name,\n      tagName: name,\n      attrs: values,\n      namespaceURI: webNamespaces[schema.space],\n      childNodes: [],\n      parentNode: undefined\n    })\n\n    // @ts-ignore Assume correct children.\n    p5.childNodes = all(node.children, p5, schema)\n\n    // @ts-ignore Types are wrong.\n    if (name === 'template') p5.content = fragment(node.content, schema)\n\n    return p5\n  }\n}\n\n/**\n * @param {Array.<Child>} children\n * @param {P5Parent} p5\n * @param {Schema} schema\n * @returns {Array.<P5Child>}\n */\nfunction all(children, p5, schema) {\n  var index = -1\n  /** @type {Array.<P5Child>} */\n  var result = []\n  /** @type {P5Child} */\n  var child\n\n  if (children) {\n    while (++index < children.length) {\n      // @ts-ignore Assume child.\n      child = one(children[index], schema)\n\n      // @ts-ignore types are wrong.\n      child.parentNode = p5\n\n      result.push(child)\n    }\n  }\n\n  return result\n}\n\n/**\n * Patch specific properties.\n *\n * @template {P5Node} T\n * @param {Node} node\n * @param {T} p5\n * @returns {T}\n */\nfunction patch(node, p5) {\n  var position = node.position\n\n  if (position && position.start && position.end) {\n    // @ts-ignore Types are wrong.\n    p5.sourceCodeLocation = {\n      startLine: position.start.line,\n      startCol: position.start.column,\n      startOffset: position.start.offset,\n      endLine: position.end.line,\n      endCol: position.end.column,\n      endOffset: position.end.offset\n    }\n  }\n\n  return p5\n}\n","/**\n * List of HTML void tag names.\n *\n * @type {Array<string>}\n */\nexport const htmlVoidElements = [\n  'area',\n  'base',\n  'basefont',\n  'bgsound',\n  'br',\n  'col',\n  'command',\n  'embed',\n  'frame',\n  'hr',\n  'image',\n  'img',\n  'input',\n  'isindex',\n  'keygen',\n  'link',\n  'menuitem',\n  'meta',\n  'nextid',\n  'param',\n  'source',\n  'track',\n  'wbr'\n]\n","/**\n * @typedef {import('vfile').VFile} VFile\n * @typedef {import('parse5').Document} P5Document\n * @typedef {import('parse5').DocumentFragment} P5Fragment\n * @typedef {Omit<import('parse5').Element, 'parentNode'>} P5Element\n * @typedef {import('parse5').Attribute} P5Attribute\n * @typedef {Omit<import('parse5').Location, 'startOffset' | 'endOffset'> & {startOffset: number|undefined, endOffset: number|undefined}} P5Location\n * @typedef {import('parse5').ParserOptions} P5ParserOptions\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').DocType} Doctype\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Text} Text\n * @typedef {import('hast').Comment} Comment\n * @typedef {import('hast').Content} Content\n * @typedef {Root|Content} Node\n * @typedef {import('../complex-types').Raw} Raw\n *\n * @typedef {Omit<Comment, 'value'> & {value: {stitch: Node}}} Stitch\n *\n * @typedef Options\n * @property {Array<string>} [passThrough]\n *   List of custom hast node types to pass through (keep) in hast.\n *   If the passed through nodes have children, those children are expected to\n *   be hast and will be handled.\n *\n * @typedef HiddenTokenizer\n * @property {Array<HiddenLocationTracker>} __mixins\n *   Way too simple, but works for us.\n * @property {HiddenPreprocessor} preprocessor\n * @property {(value: string) => void} write\n * @property {() => number} _consume\n * @property {Array<HiddenToken>} tokenQueue\n * @property {string} state\n * @property {string} returnState\n * @property {number} charRefCode\n * @property {Array<number>} tempBuff\n * @property {Function} _flushCodePointsConsumedAsCharacterReference\n * @property {string} lastStartTagName\n * @property {number} consumedAfterSnapshot\n * @property {boolean} active\n * @property {HiddenToken|undefined} currentCharacterToken\n * @property {HiddenToken|undefined} currentToken\n * @property {unknown} currentAttr\n * @property {Function} NAMED_CHARACTER_REFERENCE_STATE\n * @property {Function} NUMERIC_CHARACTER_REFERENCE_END_STATE\n *\n * @typedef {Record<string, unknown> & {location: P5Location}} HiddenToken\n *\n * @typedef HiddenPreprocessor\n * @property {string|undefined} html\n * @property {number} pos\n * @property {number} lastGapPos\n * @property {number} lastCharPos\n * @property {Array<number>} gapStack\n * @property {boolean} skipNextNewLine\n * @property {boolean} lastChunkWritten\n * @property {boolean} endOfChunkHit\n *\n * @typedef HiddenLocationTracker\n * @property {P5Location|undefined} currentAttrLocation\n * @property {P5Location} ctLoc\n * @property {HiddenPosTracker} posTracker\n *\n * @typedef HiddenPosTracker\n * @property {boolean} isEol\n * @property {number} lineStartPos\n * @property {number} droppedBufferSize\n * @property {number} offset\n * @property {number} col\n * @property {number} line\n */\n\n// @ts-expect-error: untyped.\nimport Parser from 'parse5/lib/parser/index.js'\nimport {pointStart, pointEnd} from 'unist-util-position'\nimport {visit} from 'unist-util-visit'\nimport {fromParse5} from 'hast-util-from-parse5'\nimport {toParse5} from 'hast-util-to-parse5'\nimport {htmlVoidElements} from 'html-void-elements'\nimport {webNamespaces} from 'web-namespaces'\nimport {zwitch} from 'zwitch'\n\nconst inTemplateMode = 'IN_TEMPLATE_MODE'\nconst dataState = 'DATA_STATE'\nconst characterToken = 'CHARACTER_TOKEN'\nconst startTagToken = 'START_TAG_TOKEN'\nconst endTagToken = 'END_TAG_TOKEN'\nconst commentToken = 'COMMENT_TOKEN'\nconst doctypeToken = 'DOCTYPE_TOKEN'\n\n/** @type {P5ParserOptions} */\nconst parseOptions = {sourceCodeLocationInfo: true, scriptingEnabled: false}\n\n/**\n * Given a hast tree and an optional vfile (for positional info), return a new\n * parsed-again hast tree.\n *\n * @param tree\n *   Original hast tree.\n * @param file\n *   Virtual file for positional info, optional.\n * @param options\n *   Configuration.\n */\nexport const raw =\n  /**\n   * @type {(\n   *   ((tree: Node, file: VFile|undefined, options?: Options) => Node) &\n   *   ((tree: Node, options?: Options) => Node)\n   * )}\n   */\n  (\n    /**\n     * @param {Node} tree\n     * @param {VFile} [file]\n     * @param {Options} [options]\n     */\n    function (tree, file, options) {\n      let index = -1\n      const parser = new Parser(parseOptions)\n      const one = zwitch('type', {\n        // @ts-expect-error: hush.\n        handlers: {root, element, text, comment, doctype, raw: handleRaw},\n        // @ts-expect-error: hush.\n        unknown\n      })\n      /** @type {boolean|undefined} */\n      let stitches\n      /** @type {HiddenTokenizer|undefined} */\n      let tokenizer\n      /** @type {HiddenPreprocessor|undefined} */\n      let preprocessor\n      /** @type {HiddenPosTracker|undefined} */\n      let posTracker\n      /** @type {HiddenLocationTracker|undefined} */\n      let locationTracker\n\n      if (isOptions(file)) {\n        options = file\n        file = undefined\n      }\n\n      if (options && options.passThrough) {\n        while (++index < options.passThrough.length) {\n          // @ts-expect-error: hush.\n          one.handlers[options.passThrough[index]] = stitch\n        }\n      }\n\n      const result = fromParse5(\n        documentMode(tree) ? document() : fragment(),\n        file\n      )\n\n      if (stitches) {\n        visit(result, 'comment', (node, index, parent) => {\n          const stitch = /** @type {Stitch} */ (/** @type {unknown} */ (node))\n          if (stitch.value.stitch && parent !== null && index !== null) {\n            // @ts-expect-error: assume the stitch is allowed.\n            parent.children[index] = stitch.value.stitch\n            return index\n          }\n        })\n      }\n\n      // Unpack if possible and when not given a `root`.\n      if (\n        tree.type !== 'root' &&\n        result.type === 'root' &&\n        result.children.length === 1\n      ) {\n        return result.children[0]\n      }\n\n      return result\n\n      /**\n       * @returns {P5Fragment}\n       */\n      function fragment() {\n        /** @type {P5Element} */\n        const context = {\n          nodeName: 'template',\n          tagName: 'template',\n          attrs: [],\n          namespaceURI: webNamespaces.html,\n          childNodes: []\n        }\n        /** @type {P5Element} */\n        const mock = {\n          nodeName: 'documentmock',\n          tagName: 'documentmock',\n          attrs: [],\n          namespaceURI: webNamespaces.html,\n          childNodes: []\n        }\n        /** @type {P5Fragment} */\n        const doc = {nodeName: '#document-fragment', childNodes: []}\n\n        parser._bootstrap(mock, context)\n        parser._pushTmplInsertionMode(inTemplateMode)\n        parser._initTokenizerForFragmentParsing()\n        parser._insertFakeRootElement()\n        parser._resetInsertionMode()\n        parser._findFormInFragmentContext()\n\n        tokenizer = parser.tokenizer\n        /* c8 ignore next */\n        if (!tokenizer) throw new Error('Expected `tokenizer`')\n        preprocessor = tokenizer.preprocessor\n        locationTracker = tokenizer.__mixins[0]\n        posTracker = locationTracker.posTracker\n\n        one(tree)\n\n        resetTokenizer()\n\n        parser._adoptNodes(mock.childNodes[0], doc)\n\n        return doc\n      }\n\n      /**\n       * @returns {P5Document}\n       */\n      function document() {\n        /** @type {P5Document} */\n        const doc = parser.treeAdapter.createDocument()\n\n        parser._bootstrap(doc, undefined)\n        tokenizer = parser.tokenizer\n        /* c8 ignore next */\n        if (!tokenizer) throw new Error('Expected `tokenizer`')\n        preprocessor = tokenizer.preprocessor\n        locationTracker = tokenizer.__mixins[0]\n        posTracker = locationTracker.posTracker\n\n        one(tree)\n\n        resetTokenizer()\n\n        return doc\n      }\n\n      /**\n       * @param {Array<Content>} nodes\n       * @returns {void}\n       */\n      function all(nodes) {\n        let index = -1\n\n        /* istanbul ignore else - invalid nodes, see rehypejs/rehype-raw#7. */\n        if (nodes) {\n          while (++index < nodes.length) {\n            one(nodes[index])\n          }\n        }\n      }\n\n      /**\n       * @param {Root} node\n       * @returns {void}\n       */\n      function root(node) {\n        all(node.children)\n      }\n\n      /**\n       * @param {Element} node\n       * @returns {void}\n       */\n      function element(node) {\n        resetTokenizer()\n        parser._processToken(startTag(node), webNamespaces.html)\n\n        all(node.children)\n\n        if (!htmlVoidElements.includes(node.tagName)) {\n          resetTokenizer()\n          parser._processToken(endTag(node))\n        }\n      }\n\n      /**\n       * @param {Text} node\n       * @returns {void}\n       */\n      function text(node) {\n        resetTokenizer()\n        parser._processToken({\n          type: characterToken,\n          chars: node.value,\n          location: createParse5Location(node)\n        })\n      }\n\n      /**\n       * @param {Doctype} node\n       * @returns {void}\n       */\n      function doctype(node) {\n        resetTokenizer()\n        parser._processToken({\n          type: doctypeToken,\n          name: 'html',\n          forceQuirks: false,\n          publicId: '',\n          systemId: '',\n          location: createParse5Location(node)\n        })\n      }\n\n      /**\n       * @param {Comment|Stitch} node\n       * @returns {void}\n       */\n      function comment(node) {\n        resetTokenizer()\n        parser._processToken({\n          type: commentToken,\n          data: node.value,\n          location: createParse5Location(node)\n        })\n      }\n\n      /**\n       * @param {Raw} node\n       * @returns {void}\n       */\n      function handleRaw(node) {\n        const start = pointStart(node)\n        const line = start.line || 1\n        const column = start.column || 1\n        const offset = start.offset || 0\n\n        /* c8 ignore next 4 */\n        if (!preprocessor) throw new Error('Expected `preprocessor`')\n        if (!tokenizer) throw new Error('Expected `tokenizer`')\n        if (!posTracker) throw new Error('Expected `posTracker`')\n        if (!locationTracker) throw new Error('Expected `locationTracker`')\n\n        // Reset preprocessor:\n        // See: <https://github.com/inikulin/parse5/blob/9c683e1/packages/parse5/lib/tokenizer/preprocessor.js#L17>.\n        preprocessor.html = undefined\n        preprocessor.pos = -1\n        preprocessor.lastGapPos = -1\n        preprocessor.lastCharPos = -1\n        preprocessor.gapStack = []\n        preprocessor.skipNextNewLine = false\n        preprocessor.lastChunkWritten = false\n        preprocessor.endOfChunkHit = false\n\n        // Reset preprocessor mixin:\n        // See: <https://github.com/inikulin/parse5/blob/9c683e1/packages/parse5/lib/extensions/position-tracking/preprocessor-mixin.js>.\n        posTracker.isEol = false\n        posTracker.lineStartPos = -column + 1 // Looks weird, but ensures we get correct positional info.\n        posTracker.droppedBufferSize = offset\n        posTracker.offset = 0\n        posTracker.col = 1\n        posTracker.line = line\n\n        // Reset location tracker:\n        // See: <https://github.com/inikulin/parse5/blob/9c683e1/packages/parse5/lib/extensions/location-info/tokenizer-mixin.js>.\n        locationTracker.currentAttrLocation = undefined\n        locationTracker.ctLoc = createParse5Location(node)\n\n        // See the code for `parse` and `parseFragment`:\n        // See: <https://github.com/inikulin/parse5/blob/9c683e1/packages/parse5/lib/parser/index.js#L371>.\n        tokenizer.write(node.value)\n        parser._runParsingLoop(null)\n\n        // Character references hang, so if we ended there, we need to flush\n        // those too.\n        // We reset the preprocessor as if the document ends here.\n        // Then one single call to the relevant state does the trick, parse5\n        // consumes the whole token.\n        if (\n          tokenizer.state === 'NAMED_CHARACTER_REFERENCE_STATE' ||\n          tokenizer.state === 'NUMERIC_CHARACTER_REFERENCE_END_STATE'\n        ) {\n          preprocessor.lastChunkWritten = true\n          tokenizer[tokenizer.state](tokenizer._consume())\n        }\n      }\n\n      /**\n       * @param {Node} node\n       */\n      function stitch(node) {\n        stitches = true\n\n        /** @type {Node} */\n        let clone\n\n        // Recurse, because to somewhat handle `[<x>]</x>` (where `[]` denotes the\n        // passed through node).\n        if ('children' in node) {\n          clone = {\n            ...node,\n            children: raw(\n              {type: 'root', children: node.children},\n              file,\n              options\n              // @ts-expect-error Assume a given parent yields a parent.\n            ).children\n          }\n        } else {\n          clone = {...node}\n        }\n\n        // Hack: `value` is supposed to be a string, but as none of the tools\n        // (`parse5` or `hast-util-from-parse5`) looks at it, we can pass nodes\n        // through.\n        comment({type: 'comment', value: {stitch: clone}})\n      }\n\n      function resetTokenizer() {\n        /* c8 ignore next 2 */\n        if (!tokenizer) throw new Error('Expected `tokenizer`')\n        if (!posTracker) throw new Error('Expected `posTracker`')\n\n        // Process final characters if they’re still there after hibernating.\n        // Similar to:\n        // See: <https://github.com/inikulin/parse5/blob/9c683e1/packages/parse5/lib/extensions/location-info/tokenizer-mixin.js#L95>.\n        const token = tokenizer.currentCharacterToken\n\n        if (token) {\n          token.location.endLine = posTracker.line\n          token.location.endCol = posTracker.col + 1\n          token.location.endOffset = posTracker.offset + 1\n          parser._processToken(token)\n        }\n\n        // Reset tokenizer:\n        // See: <https://github.com/inikulin/parse5/blob/9c683e1/packages/parse5/lib/tokenizer/index.js#L218-L234>.\n        // Especially putting it back in the `data` state is useful: some elements,\n        // like textareas and iframes, change the state.\n        // See GH-7.\n        // But also if broken HTML is in `raw`, and then a correct element is given.\n        // See GH-11.\n        tokenizer.tokenQueue = []\n        tokenizer.state = dataState\n        tokenizer.returnState = ''\n        tokenizer.charRefCode = -1\n        tokenizer.tempBuff = []\n        tokenizer.lastStartTagName = ''\n        tokenizer.consumedAfterSnapshot = -1\n        tokenizer.active = false\n        tokenizer.currentCharacterToken = undefined\n        tokenizer.currentToken = undefined\n        tokenizer.currentAttr = undefined\n      }\n    }\n  )\n/**\n * @param {Element} node\n * @returns {HiddenToken}\n */\nfunction startTag(node) {\n  /** @type {P5Location} */\n  const location = Object.assign(createParse5Location(node))\n  // @ts-expect-error extra positional info.\n  location.startTag = Object.assign({}, location)\n\n  // Untyped token.\n  return {\n    type: startTagToken,\n    tagName: node.tagName,\n    selfClosing: false,\n    attrs: attributes(node),\n    location\n  }\n}\n\n/**\n * @param {Element} node\n * @returns {Array<P5Attribute>}\n */\nfunction attributes(node) {\n  return toParse5({\n    tagName: node.tagName,\n    type: 'element',\n    properties: node.properties,\n    children: []\n    // @ts-expect-error Assume element.\n  }).attrs\n}\n\n/**\n * @param {Element} node\n * @returns {HiddenToken}\n */\nfunction endTag(node) {\n  /** @type {P5Location} */\n  const location = Object.assign(createParse5Location(node))\n  // @ts-expect-error extra positional info.\n  location.startTag = Object.assign({}, location)\n\n  // Untyped token.\n  return {\n    type: endTagToken,\n    tagName: node.tagName,\n    attrs: [],\n    location\n  }\n}\n\n/**\n * @param {Node} node\n */\nfunction unknown(node) {\n  throw new Error('Cannot compile `' + node.type + '` node')\n}\n\n/**\n * @param {Node} node\n * @returns {boolean}\n */\nfunction documentMode(node) {\n  const head = node.type === 'root' ? node.children[0] : node\n  return Boolean(\n    head &&\n      (head.type === 'doctype' ||\n        (head.type === 'element' && head.tagName === 'html'))\n  )\n}\n\n/**\n * @param {Node|Stitch} node\n * @returns {P5Location}\n */\nfunction createParse5Location(node) {\n  const start = pointStart(node)\n  const end = pointEnd(node)\n\n  return {\n    startLine: start.line,\n    startCol: start.column,\n    startOffset: start.offset,\n    endLine: end.line,\n    endCol: end.column,\n    endOffset: end.offset\n  }\n}\n\n/**\n * @param {VFile|Options|undefined} value\n * @return {value is Options}\n */\nfunction isOptions(value) {\n  return Boolean(value && !('message' in value && 'messages' in value))\n}\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n * @typedef {import('hast').Element} Element\n *\n * @typedef {string} TagName\n * @typedef {null|undefined|TagName|TestFunctionAnything|Array.<TagName|TestFunctionAnything>} Test\n */\n\n/**\n * @template {Element} T\n * @typedef {null|undefined|T['tagName']|TestFunctionPredicate<T>|Array.<T['tagName']|TestFunctionPredicate<T>>} PredicateTest\n */\n\n/**\n * Check if an element passes a test\n *\n * @callback TestFunctionAnything\n * @param {Element} element\n * @param {number|null|undefined} [index]\n * @param {Parent|null|undefined} [parent]\n * @returns {boolean|void}\n */\n\n/**\n * Check if an element passes a certain node test\n *\n * @template {Element} X\n * @callback TestFunctionPredicate\n * @param {Element} element\n * @param {number|null|undefined} [index]\n * @param {Parent|null|undefined} [parent]\n * @returns {element is X}\n */\n\n/**\n * Check if a node is an element and passes a certain node test\n *\n * @callback AssertAnything\n * @param {unknown} [node]\n * @param {number|null|undefined} [index]\n * @param {Parent|null|undefined} [parent]\n * @returns {boolean}\n */\n\n/**\n * Check if a node is an element and passes a certain node test\n *\n * @template {Element} Y\n * @callback AssertPredicate\n * @param {unknown} [node]\n * @param {number|null|undefined} [index]\n * @param {Parent|null|undefined} [parent]\n * @returns {node is Y}\n */\n\n// Check if `node` is an `element` and whether it passes the given test.\nexport const isElement =\n  /**\n   * Check if a node is an element and passes a test.\n   * When a `parent` node is known the `index` of node should also be given.\n   *\n   * @type {(\n   *   (() => false) &\n   *   (<T extends Element = Element>(node: unknown, test?: PredicateTest<T>, index?: number, parent?: Parent, context?: unknown) => node is T) &\n   *   ((node: unknown, test: Test, index?: number, parent?: Parent, context?: unknown) => boolean)\n   * )}\n   */\n  (\n    /**\n     * Check if a node passes a test.\n     * When a `parent` node is known the `index` of node should also be given.\n     *\n     * @param {unknown} [node] Node to check\n     * @param {Test} [test] When nullish, checks if `node` is a `Node`.\n     * When `string`, works like passing `function (node) {return node.type === test}`.\n     * When `function` checks if function passed the node is true.\n     * When `array`, checks any one of the subtests pass.\n     * @param {number} [index] Position of `node` in `parent`\n     * @param {Parent} [parent] Parent of `node`\n     * @param {unknown} [context] Context object to invoke `test` with\n     * @returns {boolean} Whether test passed and `node` is an `Element` (object with `type` set to `element` and `tagName` set to a non-empty string).\n     */\n    // eslint-disable-next-line max-params\n    function (node, test, index, parent, context) {\n      const check = convertElement(test)\n\n      if (\n        index !== undefined &&\n        index !== null &&\n        (typeof index !== 'number' ||\n          index < 0 ||\n          index === Number.POSITIVE_INFINITY)\n      ) {\n        throw new Error('Expected positive finite index for child node')\n      }\n\n      if (\n        parent !== undefined &&\n        parent !== null &&\n        (!parent.type || !parent.children)\n      ) {\n        throw new Error('Expected parent node')\n      }\n\n      // @ts-expect-error Looks like a node.\n      if (!node || !node.type || typeof node.type !== 'string') {\n        return false\n      }\n\n      if (\n        (parent === undefined || parent === null) !==\n        (index === undefined || index === null)\n      ) {\n        throw new Error('Expected both parent and index')\n      }\n\n      return check.call(context, node, index, parent)\n    }\n  )\n\nexport const convertElement =\n  /**\n   * @type {(\n   *   (<T extends Element>(test: T['tagName']|TestFunctionPredicate<T>) => AssertPredicate<T>) &\n   *   ((test?: Test) => AssertAnything)\n   * )}\n   */\n  (\n    /**\n     * Generate an assertion from a check.\n     * @param {Test} [test]\n     * When nullish, checks if `node` is a `Node`.\n     * When `string`, works like passing `function (node) {return node.type === test}`.\n     * When `function` checks if function passed the node is true.\n     * When `object`, checks that all keys in test are in node, and that they have (strictly) equal values.\n     * When `array`, checks any one of the subtests pass.\n     * @returns {AssertAnything}\n     */\n    function (test) {\n      if (test === undefined || test === null) {\n        return element\n      }\n\n      if (typeof test === 'string') {\n        return tagNameFactory(test)\n      }\n\n      if (typeof test === 'object') {\n        return anyFactory(test)\n      }\n\n      if (typeof test === 'function') {\n        return castFactory(test)\n      }\n\n      throw new Error('Expected function, string, or array as test')\n    }\n  )\n\n/**\n * @param {Array.<TagName|TestFunctionAnything>} tests\n * @returns {AssertAnything}\n */\nfunction anyFactory(tests) {\n  /** @type {Array.<AssertAnything>} */\n  const checks = []\n  let index = -1\n\n  while (++index < tests.length) {\n    checks[index] = convertElement(tests[index])\n  }\n\n  return castFactory(any)\n\n  /**\n   * @this {unknown}\n   * @param {unknown[]} parameters\n   * @returns {boolean}\n   */\n  function any(...parameters) {\n    let index = -1\n\n    while (++index < checks.length) {\n      if (checks[index].call(this, ...parameters)) {\n        return true\n      }\n    }\n\n    return false\n  }\n}\n\n/**\n * Utility to convert a string into a function which checks a given node’s tag\n * name for said string.\n *\n * @param {TagName} check\n * @returns {AssertAnything}\n */\nfunction tagNameFactory(check) {\n  return tagName\n\n  /**\n   * @param {unknown} node\n   * @returns {boolean}\n   */\n  function tagName(node) {\n    return element(node) && node.tagName === check\n  }\n}\n\n/**\n * @param {TestFunctionAnything} check\n * @returns {AssertAnything}\n */\nfunction castFactory(check) {\n  return assertion\n\n  /**\n   * @this {unknown}\n   * @param {unknown} node\n   * @param {Array.<unknown>} parameters\n   * @returns {boolean}\n   */\n  function assertion(node, ...parameters) {\n    // @ts-expect-error: fine.\n    return element(node) && Boolean(check.call(this, node, ...parameters))\n  }\n}\n\n/**\n * Utility to return true if this is an element.\n * @param {unknown} node\n * @returns {node is Element}\n */\nfunction element(node) {\n  return Boolean(\n    node &&\n      typeof node === 'object' &&\n      // @ts-expect-error Looks like a node.\n      node.type === 'element' &&\n      // @ts-expect-error Looks like an element.\n      typeof node.tagName === 'string'\n  )\n}\n","/**\n * @typedef {import('hast-util-is-element').TestFunctionAnything} TestFunctionAnything\n * @typedef {import('hast').Parent['children'][number]} HastChild\n * @typedef {import('hast').Text} HastText\n * @typedef {import('hast').Comment} HastComment\n * @typedef {import('hast').Root} HastRoot\n * @typedef {import('hast').Element} HastElement\n * @typedef {import('hast').Properties} HastProperties\n * @typedef {HastChild|HastRoot} HastNode\n * @typedef {HastRoot|HastElement} HastParent\n *\n * @typedef {'normal'|'pre'|'nowrap'|'pre-wrap'} Whitespace\n * @typedef {boolean} BreakValue\n * @typedef {1|2} BreakNumber\n * @typedef {'\\n'} BreakForce\n * @typedef {BreakValue|BreakNumber|undefined} BreakBefore\n * @typedef {BreakValue|BreakNumber|BreakForce|undefined} BreakAfter\n *\n * @typedef CollectionOptions\n * @property {Whitespace} whitespace\n * @property {BreakBefore} breakBefore\n * @property {BreakAfter} breakAfter\n *\n * @typedef Options\n *   Configuration.\n * @property {Whitespace} [whitespace='normal']\n *   Initial CSS whitespace setting to use.\n */\n\nimport {convertElement} from 'hast-util-is-element'\nimport {findAfter} from 'unist-util-find-after'\n\nconst searchLineFeeds = /\\n/g\nconst searchTabOrSpaces = /[\\t ]+/g\n\nconst br = convertElement('br')\nconst p = convertElement('p')\nconst cell = convertElement(['th', 'td'])\nconst row = convertElement('tr')\n\n// Note that we don’t need to include void elements here as they don’t have text.\n// See: <https://github.com/wooorm/html-void-elements>\nconst notRendered = convertElement([\n  // List from: <https://html.spec.whatwg.org/#hidden-elements>\n  'datalist',\n  'head',\n  'noembed',\n  'noframes',\n  'noscript', // Act as if we support scripting.\n  'rp',\n  'script',\n  'style',\n  'template',\n  'title',\n  // Hidden attribute.\n  hidden,\n  // From: <https://html.spec.whatwg.org/#flow-content-3>\n  closedDialog\n])\n\n// See: <https://html.spec.whatwg.org/#the-css-user-agent-style-sheet-and-presentational-hints>\nconst blockOrCaption = convertElement([\n  'address', // Flow content\n  'article', // Sections and headings\n  'aside', // Sections and headings\n  'blockquote', // Flow content\n  'body', // Page\n  'caption', // `table-caption`\n  'center', // Flow content (legacy)\n  'dd', // Lists\n  'dialog', // Flow content\n  'dir', // Lists (legacy)\n  'dl', // Lists\n  'dt', // Lists\n  'div', // Flow content\n  'figure', // Flow content\n  'figcaption', // Flow content\n  'footer', // Flow content\n  'form,', // Flow content\n  'h1', // Sections and headings\n  'h2', // Sections and headings\n  'h3', // Sections and headings\n  'h4', // Sections and headings\n  'h5', // Sections and headings\n  'h6', // Sections and headings\n  'header', // Flow content\n  'hgroup', // Sections and headings\n  'hr', // Flow content\n  'html', // Page\n  'legend', // Flow content\n  'listing', // Flow content (legacy)\n  'main', // Flow content\n  'menu', // Lists\n  'nav', // Sections and headings\n  'ol', // Lists\n  'p', // Flow content\n  'plaintext', // Flow content (legacy)\n  'pre', // Flow content\n  'section', // Sections and headings\n  'ul', // Lists\n  'xmp' // Flow content (legacy)\n])\n\n/**\n * Implementation of the `innerText` getter:\n * <https://html.spec.whatwg.org/#the-innertext-idl-attribute>\n * Note that we act as if `node` is being rendered, and as if we’re a\n * CSS-supporting user agent.\n *\n * @param {HastNode} node\n * @param {Options} [options={}]\n * @returns {string}\n */\nexport function toText(node, options = {}) {\n  /** @type {Array.<HastChild>} */\n  // @ts-ignore looks like a parent.\n  const children = node.children || []\n  const block = blockOrCaption(node)\n  const whitespace = inferWhitespace(node, {\n    whitespace: options.whitespace || 'normal',\n    breakBefore: false,\n    breakAfter: false\n  })\n  let index = -1\n  /** @type {Array.<string|BreakNumber>} */\n  let results\n  /** @type {string|BreakNumber} */\n  let value\n  /** @type {number|undefined} */\n  let count\n\n  // Treat `text` and `comment` as having normal white-space.\n  // This deviates from the spec as in the DOM the node’s `.data` has to be\n  // returned.\n  // If you want that behavior use `hast-util-to-string`.\n  // All other nodes are later handled as if they are `element`s (so the\n  // algorithm also works on a `root`).\n  // Nodes without children are treated as a void element, so `doctype` is thus\n  // ignored.\n  if (node.type === 'text' || node.type === 'comment') {\n    return collectText(node, {whitespace, breakBefore: true, breakAfter: true})\n  }\n\n  // 1.  If this element is not being rendered, or if the user agent is a\n  //     non-CSS user agent, then return the same value as the textContent IDL\n  //     attribute on this element.\n  //\n  //     Note: we’re not supporting stylesheets so we’re acting as if the node\n  //     is rendered.\n  //\n  //     If you want that behavior use `hast-util-to-string`.\n  //     Important: we’ll have to account for this later though.\n\n  // 2.  Let results be a new empty list.\n  results = []\n\n  // 3.  For each child node node of this element:\n  while (++index < children.length) {\n    // 3.1. Let current be the list resulting in running the inner text\n    //      collection steps with node.\n    //      Each item in results will either be a JavaScript string or a\n    //      positive integer (a required line break count).\n    // 3.2. For each item item in current, append item to results.\n    results = results.concat(\n      // @ts-ignore Looks like a parent.\n      innerTextCollection(children[index], node, {\n        whitespace,\n        breakBefore: index ? null : block,\n        breakAfter:\n          index < children.length - 1 ? br(children[index + 1]) : block\n      })\n    )\n  }\n\n  // 4.  Remove any items from results that are the empty string.\n  // 5.  Remove any runs of consecutive required line break count items at the\n  //     start or end of results.\n  // 6.  Replace each remaining run of consecutive required line break count\n  //     items with a string consisting of as many U+000A LINE FEED (LF)\n  //     characters as the maximum of the values in the required line break\n  //     count items.\n  index = -1\n  /** @type {Array.<string>} */\n  const result = []\n\n  while (++index < results.length) {\n    value = results[index]\n\n    if (typeof value === 'number') {\n      if (count !== undefined && value > count) count = value\n    } else if (value) {\n      if (count) result.push('\\n'.repeat(count))\n      count = 0\n      result.push(value)\n    }\n  }\n\n  // 7.  Return the concatenation of the string items in results.\n  return result.join('')\n}\n\n/**\n * <https://html.spec.whatwg.org/#inner-text-collection-steps>\n *\n * @param {HastNode} node\n * @param {HastParent} parent\n * @param {CollectionOptions} options\n * @returns {Array.<string|BreakNumber>}\n */\nfunction innerTextCollection(node, parent, options) {\n  if (node.type === 'element') {\n    return collectElement(node, parent, options)\n  }\n\n  if (node.type === 'text') {\n    return [\n      options.whitespace === 'normal'\n        ? collectText(node, options)\n        : collectPreText(node)\n    ]\n  }\n\n  return []\n}\n\n/**\n * Collect an element.\n *\n * @param {HastElement} node\n * @param {HastParent} parent\n * @param {CollectionOptions} options\n */\nfunction collectElement(node, parent, options) {\n  // First we infer the `white-space` property.\n  const whitespace = inferWhitespace(node, options)\n  const children = node.children || []\n  let index = -1\n  /** @type {Array.<string|BreakNumber>} */\n  let items = []\n  /** @type {BreakNumber|undefined} */\n  let prefix\n  /** @type {BreakNumber|BreakForce|undefined} */\n  let suffix\n\n  // We’re ignoring point 3, and exiting without any content here, because we\n  // deviated from the spec in `toText` at step 3.\n  if (notRendered(node)) {\n    return items\n  }\n\n  // Note: we first detect if there is going to be a break before or after the\n  // contents, as that changes the white-space handling.\n\n  // 2.  If node’s computed value of `visibility` is not `visible`, then return\n  //     items.\n  //\n  //     Note: Ignored, as everything is visible by default user agent styles.\n\n  // 3.  If node is not being rendered, then return items. [...]\n  //\n  //     Note: We already did this above.\n\n  // See `collectText` for step 4.\n\n  // 5.  If node is a `<br>` element, then append a string containing a single\n  //     U+000A LINE FEED (LF) character to items.\n  if (br(node)) {\n    suffix = '\\n'\n  }\n\n  // 7.  If node’s computed value of `display` is `table-row`, and node’s CSS\n  //     box is not the last `table-row` box of the nearest ancestor `table`\n  //     box, then append a string containing a single U+000A LINE FEED (LF)\n  //     character to items.\n  //\n  //     See: <https://html.spec.whatwg.org/#tables-2>\n  //     Note: needs further investigation as this does not account for implicit\n  //     rows.\n  else if (row(node) && findAfter(parent, node, row)) {\n    suffix = '\\n'\n  }\n\n  // 8.  If node is a `<p>` element, then append 2 (a required line break count)\n  //     at the beginning and end of items.\n  else if (p(node)) {\n    prefix = 2\n    suffix = 2\n  }\n\n  // 9.  If node’s used value of `display` is block-level or `table-caption`,\n  //     then append 1 (a required line break count) at the beginning and end of\n  //     items.\n  else if (blockOrCaption(node)) {\n    prefix = 1\n    suffix = 1\n  }\n\n  // 1.  Let items be the result of running the inner text collection steps with\n  //     each child node of node in tree order, and then concatenating the\n  //     results to a single list.\n  while (++index < children.length) {\n    items = items.concat(\n      innerTextCollection(children[index], node, {\n        whitespace,\n        breakBefore: index ? undefined : prefix,\n        breakAfter:\n          index < children.length - 1 ? br(children[index + 1]) : suffix\n      })\n    )\n  }\n\n  // 6.  If node’s computed value of `display` is `table-cell`, and node’s CSS\n  //     box is not the last `table-cell` box of its enclosing `table-row` box,\n  //     then append a string containing a single U+0009 CHARACTER TABULATION\n  //     (tab) character to items.\n  //\n  //     See: <https://html.spec.whatwg.org/#tables-2>\n  if (cell(node) && findAfter(parent, node, cell)) {\n    items.push('\\t')\n  }\n\n  // Add the pre- and suffix.\n  if (prefix) items.unshift(prefix)\n  if (suffix) items.push(suffix)\n\n  return items\n}\n\n/**\n * 4.  If node is a Text node, then for each CSS text box produced by node,\n *     in content order, compute the text of the box after application of the\n *     CSS `white-space` processing rules and `text-transform` rules, set\n *     items to the list of the resulting strings, and return items.\n *     The CSS `white-space` processing rules are slightly modified:\n *     collapsible spaces at the end of lines are always collapsed, but they\n *     are only removed if the line is the last line of the block, or it ends\n *     with a br element.\n *     Soft hyphens should be preserved.\n *\n *     Note: See `collectText` and `collectPreText`.\n *     Note: we don’t deal with `text-transform`, no element has that by\n *     default.\n *\n * See: <https://drafts.csswg.org/css-text/#white-space-phase-1>\n *\n * @param {HastText|HastComment} node\n * @param {CollectionOptions} options\n * @returns {string}\n */\nfunction collectText(node, options) {\n  const value = String(node.value)\n  /** @type {Array.<string>} */\n  const lines = []\n  /** @type {Array.<string>} */\n  const result = []\n  let start = 0\n  let index = -1\n  /** @type {RegExpMatchArray|null} */\n  let match\n  /** @type {number} */\n  let end\n  /** @type {string|undefined} */\n  let join\n\n  while (start < value.length) {\n    searchLineFeeds.lastIndex = start\n    match = searchLineFeeds.exec(value)\n    // @ts-expect-error: `index` is set.\n    end = match ? match.index : value.length\n\n    lines.push(\n      // Any sequence of collapsible spaces and tabs immediately preceding or\n      // following a segment break is removed.\n      trimAndCollapseSpacesAndTabs(\n        // [...] ignoring bidi formatting characters (characters with the\n        // Bidi_Control property [UAX9]: ALM, LTR, RTL, LRE-RLO, LRI-PDI) as if\n        // they were not there.\n        value\n          .slice(start, end)\n          .replace(/[\\u061C\\u200E\\u200F\\u202A-\\u202E\\u2066-\\u2069]/g, ''),\n        options.breakBefore,\n        options.breakAfter\n      )\n    )\n\n    start = end + 1\n  }\n\n  // Collapsible segment breaks are transformed for rendering according to the\n  // segment break transformation rules.\n  // So here we jump to 4.1.2 of [CSSTEXT]:\n  // Any collapsible segment break immediately following another collapsible\n  // segment break is removed\n  while (++index < lines.length) {\n    // *   If the character immediately before or immediately after the segment\n    //     break is the zero-width space character (U+200B), then the break is\n    //     removed, leaving behind the zero-width space.\n    if (\n      lines[index].charCodeAt(lines[index].length - 1) === 0x200b /* ZWSP */ ||\n      (index < lines.length - 1 &&\n        lines[index + 1].charCodeAt(0) === 0x200b) /* ZWSP */\n    ) {\n      result.push(lines[index])\n      join = ''\n    }\n\n    // *   Otherwise, if the East Asian Width property [UAX11] of both the\n    //     character before and after the segment break is Fullwidth, Wide, or\n    //     Halfwidth (not Ambiguous), and neither side is Hangul, then the\n    //     segment break is removed.\n    //\n    //     Note: ignored.\n    // *   Otherwise, if the writing system of the segment break is Chinese,\n    //     Japanese, or Yi, and the character before or after the segment break\n    //     is punctuation or a symbol (Unicode general category P* or S*) and\n    //     has an East Asian Width property of Ambiguous, and the character on\n    //     the other side of the segment break is Fullwidth, Wide, or Halfwidth,\n    //     and not Hangul, then the segment break is removed.\n    //\n    //     Note: ignored.\n\n    // *   Otherwise, the segment break is converted to a space (U+0020).\n    else if (lines[index]) {\n      if (join) result.push(join)\n      result.push(lines[index])\n      join = ' '\n    }\n  }\n\n  return result.join('')\n}\n\n/**\n * @param {HastText|HastComment} node\n * @returns {string}\n */\nfunction collectPreText(node) {\n  return String(node.value)\n}\n\n/**\n * 3.  Every collapsible tab is converted to a collapsible space (U+0020).\n * 4.  Any collapsible space immediately following another collapsible\n *     space—even one outside the boundary of the inline containing that\n *     space, provided both spaces are within the same inline formatting\n *     context—is collapsed to have zero advance width. (It is invisible,\n *     but retains its soft wrap opportunity, if any.)\n *\n * @param {string} value\n * @param {BreakBefore} breakBefore\n * @param {BreakAfter} breakAfter\n * @returns {string}\n */\nfunction trimAndCollapseSpacesAndTabs(value, breakBefore, breakAfter) {\n  /** @type {Array.<string>} */\n  const result = []\n  let start = 0\n  /** @type {RegExpMatchArray|null} */\n  let match\n  /** @type {number} */\n  let end\n\n  while (start < value.length) {\n    searchTabOrSpaces.lastIndex = start\n    match = searchTabOrSpaces.exec(value)\n    // @ts-expect-error: `index` is set.\n    end = match ? match.index : value.length\n\n    // If we’re not directly after a segment break, but there was white space,\n    // add an empty value that will be turned into a space.\n    if (!start && !end && match && !breakBefore) {\n      result.push('')\n    }\n\n    if (start !== end) {\n      result.push(value.slice(start, end))\n    }\n\n    start = match ? end + match[0].length : end\n  }\n\n  // If we reached the end, there was trailing white space, and there’s no\n  // segment break after this node, add an empty value that will be turned\n  // into a space.\n  // @ts-expect-error: `end` is defined.\n  if (start !== end && !breakAfter) {\n    result.push('')\n  }\n\n  return result.join(' ')\n}\n\n/**\n * We don’t support void elements here (so `nobr wbr` -> `normal` is ignored).\n *\n * @param {HastNode} node\n * @param {CollectionOptions} options\n * @returns {Whitespace}\n */\nfunction inferWhitespace(node, options) {\n  /** @type {HastProperties} */\n  let props\n\n  if (node.type === 'element') {\n    props = node.properties || {}\n    switch (node.tagName) {\n      case 'listing':\n      case 'plaintext':\n      case 'xmp':\n        return 'pre'\n      case 'nobr':\n        return 'nowrap'\n      case 'pre':\n        return props.wrap ? 'pre-wrap' : 'pre'\n      case 'td':\n      case 'th':\n        return props.noWrap ? 'nowrap' : options.whitespace\n      case 'textarea':\n        return 'pre-wrap'\n      default:\n    }\n  }\n\n  return options.whitespace\n}\n\n/** @type {TestFunctionAnything} */\nfunction hidden(node) {\n  return Boolean((node.properties || {}).hidden)\n}\n\n/** @type {TestFunctionAnything} */\nfunction closedDialog(node) {\n  return node.tagName === 'dialog' && !(node.properties || {}).open\n}\n","/**\n * @param {unknown} thing\n * @returns {boolean}\n */\nexport function whitespace(thing) {\n  /** @type {string} */\n  var value =\n    // @ts-ignore looks like a node.\n    thing && typeof thing === 'object' && thing.type === 'text'\n      ? // @ts-ignore looks like a text.\n        thing.value || ''\n      : thing\n\n  // HTML whitespace expression.\n  // See <https://html.spec.whatwg.org/#space-character>.\n  return typeof value === 'string' && value.replace(/[ \\t\\n\\f\\r]/g, '') === ''\n}\n"],"names":["COMMENT_REGEX","NEWLINE_REGEX","WHITESPACE_REGEX","PROPERTY_REGEX","COLON_REGEX","VALUE_REGEX","SEMICOLON_REGEX","TRIM_REGEX","EMPTY_STRING","trim","str","replace","module","exports","style","options","TypeError","lineno","column","updatePosition","lines","match","length","i","lastIndexOf","position","start","line","node","Position","whitespace","this","end","source","prototype","content","errorsList","error","msg","err","Error","reason","filename","silent","push","re","m","exec","slice","comments","rules","c","comment","pos","charAt","type","declaration","prop","val","ret","property","value","decl","decls","declarations","search","parseSelector","selector","subvalue","previous","defaultTagName","props","lastIndex","index","id","Array","isArray","className","tagName","properties","children","buttonTypes","Set","own","hasOwnProperty","core","schema","caseSensitive","adjust","values","result","toLowerCase","createAdjustMap","key","undefined","unshift","call","isProperties","addProperty","addChild","name","has","info","find","Number","isNaN","spaceSeparated","spaces","commaSeparated","commas","commaOrSpaceSeparated","join","parsePrimitive","concat","String","finalResult","nodes","number","boolean","overloadedBoolean","normalize","s","svg","h","html","map","root","_","ast","data","fromParse5","settings","file","isFile","transform","space","verbose","location","ctx","fn","nodeName","element","namespaceURI","webNamespaces","childNodes","sourceCodeLocation","tail","endTag","Object","assign","attrs","opening","startTag","closing","createLocation","quirksMode","mode","doc","loc","toPoint","attribute","prefix","point","startLine","startCol","offset","startOffset","endLine","endCol","endOffset","ns","toReact","hastToReact","convert","text","toH","tree","r","Boolean","react","v","context","_isVue","vue","vd","vdom","hyperscript","parentSchema","attributes","addAttribute","toUpperCase","namespace","subprop","$1","message","parseStyle","mustUseProperty","one","zwitch","handlers","p5","all","patch","indexOf","parentNode","fragment","doctype","publicId","systemId","child","htmlVoidElements","endTagToken","parseOptions","sourceCodeLocationInfo","scriptingEnabled","raw","stitches","tokenizer","preprocessor","posTracker","locationTracker","parser","Parser","resetTokenizer","_processToken","includes","createParse5Location","chars","forceQuirks","pointStart","lastGapPos","lastCharPos","gapStack","skipNextNewLine","lastChunkWritten","endOfChunkHit","isEol","lineStartPos","droppedBufferSize","col","currentAttrLocation","ctLoc","write","_runParsingLoop","state","_consume","unknown","passThrough","stitch","head","documentMode","treeAdapter","createDocument","_bootstrap","__mixins","document","mock","_pushTmplInsertionMode","_initTokenizerForFragmentParsing","_insertFakeRootElement","_resetInsertionMode","_findFormInFragmentContext","_adoptNodes","visit","parent","token","currentCharacterToken","tokenQueue","returnState","charRefCode","tempBuff","lastStartTagName","consumedAfterSnapshot","active","currentToken","currentAttr","selfClosing","pointEnd","convertElement","test","check","tagNameFactory","anyFactory","castFactory","tests","checks","parameters","searchLineFeeds","searchTabOrSpaces","br","p","cell","row","notRendered","hidden","open","blockOrCaption","toText","results","count","block","inferWhitespace","breakBefore","breakAfter","collectText","innerTextCollection","repeat","suffix","items","findAfter","collectElement","collectPreText","trimAndCollapseSpacesAndTabs","charCodeAt","wrap","noWrap","thing"],"sourceRoot":""}